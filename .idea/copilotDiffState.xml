<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ArrayOperationBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ArrayOperationBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class ArrayOperationBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntArray_IndexOf_Lookup()&#10;        {&#10;            var collection = intSourceData.ToArray();&#10;            foreach (var item in intLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringArray_IndexOf_Lookup()&#10;        {&#10;            var collection = stringSourceData.ToArray();&#10;            foreach (var item in stringLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntArray_BinarySearch_Lookup()&#10;        {&#10;            var collection = intSourceData.ToArray();&#10;            Array.Sort(collection);&#10;            foreach (var item in intLookupItems)&#10;                _ = Array.BinarySearch(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringArray_BinarySearch_Lookup()&#10;        {&#10;            var collection = stringSourceData.ToArray();&#10;            Array.Sort(collection);&#10;            foreach (var item in stringLookupItems)&#10;                _ = Array.BinarySearch(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntArray_Contains_Lookup()&#10;        {&#10;            var collection = intSourceData.ToArray();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringArray_Contains_Lookup()&#10;        {&#10;            var collection = stringSourceData.ToArray();&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ConcurrentCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ConcurrentCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class ConcurrentCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntConcurrentDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentDictionary&lt;int, bool&gt;(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringConcurrentDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentDictionary&lt;string, bool&gt;(stringSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntConcurrentBag_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentBag&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringConcurrentBag_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentBag&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/CustomReferenceTypeBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/CustomReferenceTypeBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    // Custom reference type for testing&#10;    public class Customer : IEquatable&lt;Customer&gt;, IComparable&lt;Customer&gt;&#10;    {&#10;        public string Id { get; }&#10;        public string Name { get; }&#10;        &#10;        public Customer(string id, string name)&#10;        {&#10;            Id = id;&#10;            Name = name;&#10;        }&#10;        &#10;        public bool Equals(Customer? other) =&gt; other != null &amp;&amp; Id == other.Id;&#10;        public override bool Equals(object? obj) =&gt; Equals(obj as Customer);&#10;        public override int GetHashCode() =&gt; Id?.GetHashCode() ?? 0;&#10;        &#10;        public int CompareTo(Customer? other)&#10;        {&#10;            if (other == null) return 1;&#10;            return string.Compare(Id, other.Id, StringComparison.Ordinal);&#10;        }&#10;    }&#10;&#10;    [MemoryDiagnoser]&#10;    public class CustomReferenceTypeBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private Customer[] customerSourceData = null!;&#10;        private Customer[] customerLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            customerSourceData = Enumerable.Range(1, N).Select(i =&gt; new Customer($&quot;CUST_{random.Next()}&quot;, $&quot;Customer {i}&quot;)).ToArray();&#10;            customerLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; new Customer($&quot;CUST_{random.Next()}&quot;, $&quot;Customer {i}&quot;)).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;Customer&gt;(customerSourceData);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;Customer&gt;(customerSourceData);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;Customer&gt;(customerSourceData);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerDictionary_CreationAndLookup()&#10;        {&#10;            var collection = customerSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/CustomValueTypeBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/CustomValueTypeBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    // Custom value type for testing&#10;    public struct ProductId : IEquatable&lt;ProductId&gt;, IComparable&lt;ProductId&gt;&#10;    {&#10;        public int Value { get; }&#10;        &#10;        public ProductId(int value) =&gt; Value = value;&#10;        &#10;        public bool Equals(ProductId other) =&gt; Value == other.Value;&#10;        public override bool Equals(object? obj) =&gt; obj is ProductId other &amp;&amp; Equals(other);&#10;        public override int GetHashCode() =&gt; Value.GetHashCode();&#10;        public static implicit operator ProductId(int value) =&gt; new(value);&#10;        &#10;        public int CompareTo(ProductId other) =&gt; Value.CompareTo(other.Value);&#10;    }&#10;&#10;    [MemoryDiagnoser]&#10;    public class CustomValueTypeBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private ProductId[] productIdSourceData = null!;&#10;        private ProductId[] productIdLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            productIdSourceData = Enumerable.Range(1, N).Select(i =&gt; new ProductId(random.Next())).Distinct().Take(N).ToArray();&#10;            productIdLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; new ProductId(random.Next())).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;ProductId&gt;(productIdSourceData);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;ProductId&gt;(productIdSourceData);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;ProductId&gt;(productIdSourceData);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdDictionary_CreationAndLookup()&#10;        {&#10;            var collection = productIdSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/GuidCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/GuidCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class GuidCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private Guid[] guidSourceData = null!;&#10;        private Guid[] guidLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            guidSourceData = Enumerable.Range(1, N).Select(i =&gt; Guid.NewGuid()).ToArray();&#10;            guidLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; Guid.NewGuid()).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;Guid&gt;(guidSourceData);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;Guid&gt;(guidSourceData);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;Guid&gt;(guidSourceData);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidDictionary_CreationAndLookup()&#10;        {&#10;            var collection = guidSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidSortedDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new SortedDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ImmutableCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ImmutableCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class ImmutableCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableList_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableList.CreateRange(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableHashSet_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableHashSet.CreateRange(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableSortedSet.CreateRange(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringImmutableList_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableList.CreateRange(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringImmutableHashSet_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableHashSet.CreateRange(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableDictionary_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableDictionary.CreateRange(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/IntegerCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/IntegerCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class IntegerCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntDictionary_CreationAndLookup()&#10;        {&#10;            var collection = intSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntSortedDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new SortedDictionary&lt;int, bool&gt;(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ParallelBenchmarkRunner.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ParallelBenchmarkRunner.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Diagnostics;&#10;using System.Threading.Tasks;&#10;using BenchmarkDotNet.Running;&#10;using BenchmarkDotNet.Configs;&#10;using BenchmarkDotNet.Jobs;&#10;using BenchmarkDotNet.Toolchains.CsProj;&#10;using BenchmarkDotNet.Toolchains.DotNetCli;&#10;&#10;namespace Benchmarks&#10;{&#10;    public class ParallelBenchmarkRunner&#10;    {&#10;        private readonly int _parallelInstances;&#10;        private readonly ManualConfig _releaseConfig;&#10;&#10;        public ParallelBenchmarkRunner(int parallelInstances = 8)&#10;        {&#10;            _parallelInstances = parallelInstances;&#10;            &#10;            // Create optimized release configuration&#10;            _releaseConfig = ManualConfig.Create(DefaultConfig.Instance)&#10;                .WithOptions(ConfigOptions.DisableOptimizationsValidator)&#10;                .AddJob(Job.Default&#10;                    .WithToolchain(CsProjCoreToolchain.NetCoreApp90)&#10;                    .WithId(&quot;ReleaseJob&quot;))&#10;                .WithOption(ConfigOptions.JoinSummary, true);&#10;        }&#10;&#10;        public async Task RunBenchmarksInParallel()&#10;        {&#10;            Console.WriteLine($&quot;Starting parallel benchmark execution with {_parallelInstances} instances...&quot;);&#10;            Console.WriteLine($&quot;CPU Core Count: {Environment.ProcessorCount}&quot;);&#10;            Console.WriteLine(new string('=', 80));&#10;&#10;            var benchmarkTasks = new List&lt;Task&gt;();&#10;            var results = new ConcurrentBag&lt;BenchmarkResult&gt;();&#10;            var stopwatch = Stopwatch.StartNew();&#10;&#10;            // Define different benchmark scenarios to run in parallel&#10;            var benchmarkScenarios = new List&lt;BenchmarkScenario&gt;&#10;            {&#10;                new(&quot;IntegerCollections&quot;, () =&gt; RunBenchmarkSafely&lt;IntegerCollectionBenchmarks&gt;()),&#10;                new(&quot;StringCollections&quot;, () =&gt; RunBenchmarkSafely&lt;StringCollectionBenchmarks&gt;()),&#10;                new(&quot;GuidCollections&quot;, () =&gt; RunBenchmarkSafely&lt;GuidCollectionBenchmarks&gt;()),&#10;                new(&quot;CustomValueTypes&quot;, () =&gt; RunBenchmarkSafely&lt;CustomValueTypeBenchmarks&gt;()),&#10;                new(&quot;CustomReferenceTypes&quot;, () =&gt; RunBenchmarkSafely&lt;CustomReferenceTypeBenchmarks&gt;()),&#10;                new(&quot;ImmutableCollections&quot;, () =&gt; RunBenchmarkSafely&lt;ImmutableCollectionBenchmarks&gt;()),&#10;                new(&quot;ConcurrentCollections&quot;, () =&gt; RunBenchmarkSafely&lt;ConcurrentCollectionBenchmarks&gt;()),&#10;                new(&quot;ArrayOperations&quot;, () =&gt; RunBenchmarkSafely&lt;ArrayOperationBenchmarks&gt;())&#10;            };&#10;&#10;            // Take only the number of scenarios we want to run in parallel&#10;            var scenariosToRun = benchmarkScenarios.Take(_parallelInstances);&#10;&#10;            foreach (var scenario in scenariosToRun)&#10;            {&#10;                var task = Task.Run(async () =&gt;&#10;                {&#10;                    var taskStopwatch = Stopwatch.StartNew();&#10;                    Console.WriteLine($&quot;[{DateTime.Now:HH:mm:ss}] Starting {scenario.Name}...&quot;);&#10;                    &#10;                    try&#10;                    {&#10;                        var result = await scenario.ExecuteAsync();&#10;                        taskStopwatch.Stop();&#10;                        &#10;                        var benchmarkResult = new BenchmarkResult&#10;                        {&#10;                            ScenarioName = scenario.Name,&#10;                            Success = result != null,&#10;                            Duration = taskStopwatch.Elapsed,&#10;                            ErrorMessage = result == null ? &quot;Benchmark returned null&quot; : null&#10;                        };&#10;                        &#10;                        results.Add(benchmarkResult);&#10;                        Console.WriteLine($&quot;[{DateTime.Now:HH:mm:ss}] Completed {scenario.Name} in {taskStopwatch.Elapsed:mm\\:ss}&quot;);&#10;                    }&#10;                    catch (Exception ex)&#10;                    {&#10;                        taskStopwatch.Stop();&#10;                        var benchmarkResult = new BenchmarkResult&#10;                        {&#10;                            ScenarioName = scenario.Name,&#10;                            Success = false,&#10;                            Duration = taskStopwatch.Elapsed,&#10;                            ErrorMessage = ex.Message&#10;                        };&#10;                        &#10;                        results.Add(benchmarkResult);&#10;                        Console.WriteLine($&quot;[{DateTime.Now:HH:mm:ss}] Failed {scenario.Name}: {ex.Message}&quot;);&#10;                    }&#10;                });&#10;                &#10;                benchmarkTasks.Add(task);&#10;            }&#10;&#10;            // Wait for all benchmarks to complete&#10;            await Task.WhenAll(benchmarkTasks);&#10;            stopwatch.Stop();&#10;&#10;            // Print summary&#10;            Console.WriteLine(&quot;\n&quot; + new string('=', 80));&#10;            Console.WriteLine(&quot;PARALLEL BENCHMARK EXECUTION SUMMARY&quot;);&#10;            Console.WriteLine(new string('=', 80));&#10;            Console.WriteLine($&quot;Total Execution Time: {stopwatch.Elapsed:mm\\:ss}&quot;);&#10;            Console.WriteLine($&quot;Parallel Instances: {_parallelInstances}&quot;);&#10;            Console.WriteLine();&#10;&#10;            foreach (var result in results)&#10;            {&#10;                var status = result.Success ? &quot;✓ SUCCESS&quot; : &quot;✗ FAILED&quot;;&#10;                Console.WriteLine($&quot;{status,-12} {result.ScenarioName,-25} Duration: {result.Duration:mm\\:ss}&quot;);&#10;                if (!result.Success &amp;&amp; !string.IsNullOrEmpty(result.ErrorMessage))&#10;                {&#10;                    Console.WriteLine($&quot;             Error: {result.ErrorMessage}&quot;);&#10;                }&#10;            }&#10;&#10;            var successCount = results.Count(r =&gt; r.Success);&#10;            var failCount = results.Count(r =&gt; !r.Success);&#10;            &#10;            Console.WriteLine();&#10;            Console.WriteLine($&quot;Results: {successCount} successful, {failCount} failed&quot;);&#10;            Console.WriteLine(new string('=', 80));&#10;        }&#10;&#10;        private async Task&lt;object&gt; RunBenchmarkSafely&lt;T&gt;() where T : class&#10;        {&#10;            return await Task.Run(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    return BenchmarkRunner.Run&lt;T&gt;(_releaseConfig);&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    Console.WriteLine($&quot;Error running benchmark {typeof(T).Name}: {ex.Message}&quot;);&#10;                    throw;&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    public record BenchmarkScenario(string Name, Func&lt;Task&lt;object&gt;&gt; ExecuteAsync);&#10;&#10;    public class BenchmarkResult&#10;    {&#10;        public string ScenarioName { get; set; } = string.Empty;&#10;        public bool Success { get; set; }&#10;        public TimeSpan Duration { get; set; }&#10;        public string? ErrorMessage { get; set; }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ParallelizedGuidBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ParallelizedGuidBenchmarks.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.Diagnostics;&#10;using System.IO;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using BenchmarkDotNet.Attributes;&#10;using BenchmarkDotNet.Jobs;&#10;using BenchmarkDotNet.Engines;&#10;&#10;namespace Benchmarks&#10;{&#10;    [SimpleJob(RunStrategy.Monitoring, warmupCount: 5, iterationCount: 50)]&#10;    [MemoryDiagnoser]&#10;    [HardwareCounters(HardwareCounter.BranchMispredictions, HardwareCounter.CacheMisses)]&#10;    public class ParallelizedGuidBenchmarks&#10;    {&#10;        [Params(10, 100, 1000, 10000)]&#10;        public int N { get; set; }&#10;&#10;        [Params(10, 100, 1000, 10000)]&#10;        public int LookupCount { get; set; }&#10;&#10;        private Guid[] guidSourceData = null!;&#10;        private Guid[] guidLookupItems = null!;&#10;        private static readonly object _fileLock = new object();&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            // Generate N unique GUIDs for the collection&#10;            guidSourceData = new Guid[N];&#10;            for (int i = 0; i &lt; N; i++)&#10;            {&#10;                guidSourceData[i] = Guid.NewGuid();&#10;            }&#10;&#10;            // Generate lookup items (mix of existing and non-existing GUIDs)&#10;            guidLookupItems = new Guid[LookupCount];&#10;            var random = new Random(42); // Fixed seed for reproducibility&#10;&#10;            for (int i = 0; i &lt; LookupCount; i++)&#10;            {&#10;                if (i &lt; N &amp;&amp; random.NextDouble() &lt; 0.7) // 70% chance to use existing GUID&#10;                {&#10;                    guidLookupItems[i] = guidSourceData[random.Next(N)];&#10;                }&#10;                else // 30% chance to use non-existing GUID&#10;                {&#10;                    guidLookupItems[i] = Guid.NewGuid();&#10;                }&#10;            }&#10;        }&#10;&#10;        [IterationCleanup]&#10;        public void IterationCleanup()&#10;        {&#10;            // Force garbage collection between iterations to prevent memory pressure interference&#10;            GC.Collect();&#10;            GC.WaitForPendingFinalizers();&#10;            GC.Collect();&#10;        }&#10;&#10;        private void LogDetailedResults(string collectionType, int n, int lookupCount, TimeSpan creationTime, TimeSpan lookupTime, TimeSpan totalTime)&#10;        {&#10;            // Use a hardcoded absolute path to ensure we can find it&#10;            var logPath = @&quot;C:\Users\Gustavo\Documents\Projetos\Estudos_Csharp\CSharpStudies\Topic6\Benchmarks\BenchmarkDotNet.Artifacts\detailed_results_guid.txt&quot;;&#10;            &#10;            // Ensure directory exists&#10;            Directory.CreateDirectory(Path.GetDirectoryName(logPath));&#10;            &#10;            lock (_fileLock)&#10;            {&#10;                try&#10;                {&#10;                    // Check if we need to write header BEFORE opening the file&#10;                    bool needsHeader = !File.Exists(logPath) || new FileInfo(logPath).Length == 0;&#10;                    &#10;                    using var writer = new StreamWriter(logPath, true);&#10;                    if (needsHeader)&#10;                    {&#10;                        // Write header if file doesn't exist or is empty&#10;                        writer.WriteLine(&quot;CollectionType,N,LookupCount,CreationTime_μs,LookupTime_μs,TotalTime_μs&quot;);&#10;                    }&#10;                    writer.WriteLine($&quot;{collectionType},{n},{lookupCount},{creationTime.TotalMicroseconds:F2},{lookupTime.TotalMicroseconds:F2},{totalTime.TotalMicroseconds:F2}&quot;);&#10;                    &#10;                    // Force write to disk&#10;                    writer.Flush();&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    // If there's an issue, write to a backup location we can debug&#10;                    var backupPath = @&quot;C:\temp\benchmark_debug_guid.txt&quot;;&#10;                    Directory.CreateDirectory(Path.GetDirectoryName(backupPath));&#10;                    File.AppendAllText(backupPath, $&quot;ERROR: {ex.Message}\n&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidArray_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = guidSourceData.ToArray();&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Array&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidList_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new List&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;List&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidHashSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new HashSet&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;HashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidSortedSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedSet&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = guidSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Dictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidSortedDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidConcurrentDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new ConcurrentDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ConcurrentDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidImmutableList_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableList.CreateRange(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableList&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidImmutableHashSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableHashSet.CreateRange(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableHashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.Diagnostics;&#10;using System.IO;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using BenchmarkDotNet.Attributes;&#10;using BenchmarkDotNet.Jobs;&#10;using BenchmarkDotNet.Engines;&#10;&#10;namespace Benchmarks&#10;{&#10;    [SimpleJob(RunStrategy.Monitoring, warmupCount: 5, iterationCount: 50)]&#10;    [MemoryDiagnoser]&#10;    public class ParallelizedGuidBenchmarks&#10;    {&#10;        [Params(10, 100, 1000, 10000)]&#10;        public int N { get; set; }&#10;&#10;        [Params(10, 100, 1000, 10000)]&#10;        public int LookupCount { get; set; }&#10;&#10;        private Guid[] guidSourceData = null!;&#10;        private Guid[] guidLookupItems = null!;&#10;        private static readonly object _fileLock = new object();&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            // Generate N unique GUIDs for the collection&#10;            guidSourceData = new Guid[N];&#10;            for (int i = 0; i &lt; N; i++)&#10;            {&#10;                guidSourceData[i] = Guid.NewGuid();&#10;            }&#10;&#10;            // Generate lookup items (mix of existing and non-existing GUIDs)&#10;            guidLookupItems = new Guid[LookupCount];&#10;            var random = new Random(42); // Fixed seed for reproducibility&#10;&#10;            for (int i = 0; i &lt; LookupCount; i++)&#10;            {&#10;                if (i &lt; N &amp;&amp; random.NextDouble() &lt; 0.7) // 70% chance to use existing GUID&#10;                {&#10;                    guidLookupItems[i] = guidSourceData[random.Next(N)];&#10;                }&#10;                else // 30% chance to use non-existing GUID&#10;                {&#10;                    guidLookupItems[i] = Guid.NewGuid();&#10;                }&#10;            }&#10;        }&#10;&#10;        [IterationCleanup]&#10;        public void IterationCleanup()&#10;        {&#10;            // Force garbage collection between iterations to prevent memory pressure interference&#10;            GC.Collect();&#10;            GC.WaitForPendingFinalizers();&#10;            GC.Collect();&#10;        }&#10;&#10;        private void LogDetailedResults(string collectionType, int n, int lookupCount, TimeSpan creationTime, TimeSpan lookupTime, TimeSpan totalTime)&#10;        {&#10;            // Use a hardcoded absolute path to ensure we can find it&#10;            var logPath = @&quot;C:\Users\Gustavo\Documents\Projetos\Estudos_Csharp\CSharpStudies\Topic6\Benchmarks\BenchmarkDotNet.Artifacts\detailed_results_guid.txt&quot;;&#10;            &#10;            // Ensure directory exists&#10;            Directory.CreateDirectory(Path.GetDirectoryName(logPath));&#10;            &#10;            lock (_fileLock)&#10;            {&#10;                try&#10;                {&#10;                    // Check if we need to write header BEFORE opening the file&#10;                    bool needsHeader = !File.Exists(logPath) || new FileInfo(logPath).Length == 0;&#10;                    &#10;                    using var writer = new StreamWriter(logPath, true);&#10;                    if (needsHeader)&#10;                    {&#10;                        // Write header if file doesn't exist or is empty&#10;                        writer.WriteLine(&quot;CollectionType,N,LookupCount,CreationTime_μs,LookupTime_μs,TotalTime_μs&quot;);&#10;                    }&#10;                    writer.WriteLine($&quot;{collectionType},{n},{lookupCount},{creationTime.TotalMicroseconds:F2},{lookupTime.TotalMicroseconds:F2},{totalTime.TotalMicroseconds:F2}&quot;);&#10;                    &#10;                    // Force write to disk&#10;                    writer.Flush();&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    // If there's an issue, write to a backup location we can debug&#10;                    var backupPath = @&quot;C:\temp\benchmark_debug_guid.txt&quot;;&#10;                    Directory.CreateDirectory(Path.GetDirectoryName(backupPath));&#10;                    File.AppendAllText(backupPath, $&quot;ERROR: {ex.Message}\n&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidArray_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = guidSourceData.ToArray();&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Array&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidList_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new List&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;List&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidHashSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new HashSet&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;HashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidSortedSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedSet&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = guidSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Dictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidSortedDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidConcurrentDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new ConcurrentDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ConcurrentDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidImmutableList_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableList.CreateRange(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableList&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidImmutableHashSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableHashSet.CreateRange(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableHashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/Program.cs" />
              <option name="originalContent" value="using System;&#10;using System.IO;&#10;using System.Linq;&#10;namespace Benchmarks&#10;{&#10;    public class Program&#10;    {&#10;        public static void Main(string[] args)&#10;        {&#10;            if (args.Length == 0)&#10;            {&#10;                ShowHelp();&#10;                return;&#10;            }&#10;&#10;            var command = args[0].ToLower();&#10;&#10;            switch (command)&#10;            {&#10;                case &quot;benchmark&quot;:&#10;                case &quot;bench&quot;:&#10;                case &quot;b&quot;:&#10;                    var dataType = args.Length &gt; 1 ? args[1].ToLower() : &quot;int&quot;;&#10;                    var dataType = args.Length &gt; 1 ? args[1].ToLower() : &quot;int&quot;;&#10;                    var priority = args.Length &gt; 2 ? args[2].ToLower() : &quot;normal&quot;;&#10;                    RunBenchmarks(dataType, priority);&#10;                    break;&#10;                    &#10;                case &quot;analyze&quot;:&#10;                case &quot;analysis&quot;:&#10;                case &quot;a&quot;:&#10;                case &quot;summary&quot;:&#10;                case &quot;sum&quot;:&#10;                case &quot;s&quot;:&#10;                    var analyzeDataType = args.Length &gt; 1 ? args[1].ToLower() : &quot;int&quot;;&#10;                    var analyzePriority = args.Length &gt; 2 ? args[2].ToLower() : &quot;normal&quot;;&#10;                    RunStatisticalAnalysis(analyzeDataType, analyzePriority);&#10;                    break;&#10;&#10;                case &quot;full&quot;:&#10;                case &quot;f&quot;:&#10;                    var fullDataType = args.Length &gt; 1 ? args[1].ToLower() : &quot;int&quot;;&#10;                    var fullPriority = args.Length &gt; 2 ? args[2].ToLower() : &quot;normal&quot;;&#10;                    RunFullBenchmarkAndAnalysis(fullDataType, fullPriority);&#10;                    RunStatisticalAnalysis(analyzeDataType, analyzePriority);&#10;                    break;&#10;                    &#10;                case &quot;full&quot;:&#10;                case &quot;f&quot;:&#10;                    var fullDataType = args.Length &gt; 1 ? args[1].ToLower() : &quot;int&quot;;&#10;                    var fullPriority = args.Length &gt; 2 ? args[2].ToLower() : &quot;normal&quot;;&#10;                    RunFullBenchmarkAndAnalysis(fullDataType, fullPriority);&#10;                    break;&#10;                    &#10;                case &quot;help&quot;:&#10;                case &quot;h&quot;:&#10;                case &quot;?&quot;:&#10;                    ShowHelp();&#10;                    break;&#10;                    &#10;                default:&#10;                    Console.WriteLine($&quot;Unknown command: {command}&quot;);&#10;                    ShowHelp();&#10;            Console.WriteLine(&quot;Usage: dotnet run -c Release &lt;command&gt; [datatype] [priority]&quot;);&#10;            }&#10;        }&#10;            Console.WriteLine(&quot;  benchmark, bench, b    - Run collection benchmarks (50 iterations each)&quot;);&#10;        private static void ShowHelp()&#10;        {&#10;            Console.WriteLine(&quot;  full, f               - Run benchmarks AND analysis in sequence&quot;);&#10;            Console.WriteLine(&quot;=== C# Collection Performance Benchmarks ===&quot;);&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;Usage: dotnet run -c Release &lt;command&gt; [datatype] [priority]&quot;);&#10;            Console.WriteLine(&quot;  int, integer          - Integer benchmarks (default)&quot;);&#10;            Console.WriteLine(&quot;Commands:&quot;);&#10;            Console.WriteLine(&quot;  benchmark, bench, b    - Run collection benchmarks (50 iterations each)&quot;);&#10;            Console.WriteLine(&quot;  analyze, analysis, a   - Analyze existing results with statistics&quot;);&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;Priority Levels:&quot;);&#10;            Console.WriteLine(&quot;  normal                - Normal process priority (default)&quot;);&#10;            Console.WriteLine(&quot;  high                  - High process priority&quot;);&#10;            Console.WriteLine(&quot;  realtime              - RealTime process priority&quot;);&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;Features:&quot;);&#10;            Console.WriteLine(&quot;  • Configurable process priority for different scenarios&quot;);&#10;            Console.WriteLine(&quot;  • Priority-specific result files for comparison&quot;);&#10;            Console.WriteLine(&quot;  • Comprehensive variance analysis&quot;);&#10;            Console.WriteLine(&quot;  • Outlier detection and removal&quot;);&#10;            Console.WriteLine(&quot;  • Statistical summaries and performance reports&quot;);&#10;            Console.WriteLine(&quot;  summary, sum, s        - Same as analyze (alias)&quot;);&#10;            Console.WriteLine(&quot;  full, f               - Run benchmarks AND analysis in sequence&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark int normal         # Run integer benchmarks with normal priority&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark int high           # Run integer benchmarks with high priority&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark int realtime       # Run integer benchmarks with realtime priority&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release analyze int normal           # Analyze normal priority results&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release full guid high               # Run GUID benchmarks + analysis with high priority&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release b                           # Short form integer benchmark (normal priority)&quot;);&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;Note: Each priority level creates separate result files for comparison.&quot;);&#10;            Console.WriteLine(&quot;      Results are saved with priority suffix (e.g., detailed_results_integer_normal.txt)&quot;);&#10;            Console.WriteLine(&quot;  high                  - High process priority&quot;);&#10;            Console.WriteLine(&quot;  realtime              - RealTime process priority&quot;);&#10;        private static void RunBenchmarks(string dataType, string priority)&#10;            Console.WriteLine(&quot;Features:&quot;);&#10;            Console.WriteLine(&quot;=== Running Collection Performance Benchmarks ===&quot;);&#10;            Console.WriteLine($&quot;The process will be configured with {priority.ToUpper()} priority:&quot;);&#10;            Console.WriteLine($&quot;• {GetPriorityDescription(priority)}&quot;);&#10;            Console.WriteLine(&quot;• Natural multi-core scheduling&quot;);&#10;            Console.WriteLine(&quot;• Multiple iterations with statistical analysis&quot;);&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;  • Comprehensive variance analysis&quot;);&#10;            Console.WriteLine(&quot;  • Outlier detection and removal&quot;);&#10;            Console.WriteLine(&quot;  • Statistical summaries and performance reports&quot;);&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;Examples:&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark int normal         # Run integer benchmarks with normal priority&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark int high           # Run integer benchmarks with high priority&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark int realtime       # Run integer benchmarks with realtime priority&quot;);&#10;                    Console.WriteLine($&quot;Running INTEGER benchmarks with {priority} priority...&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release full guid high               # Run GUID benchmarks + analysis with high priority&quot;);&#10;                    intBenchmarks.RunManual(priority);&#10;                    Console.WriteLine(&quot;✓ Integer benchmarks completed!&quot;);&#10;                    Console.WriteLine($&quot;Results saved to: result/detailed_results_integer_{priority}.txt&quot;);&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;Note: Each priority level creates separate result files for comparison.&quot;);&#10;            Console.WriteLine(&quot;      Results are saved with priority suffix (e.g., detailed_results_integer_normal.txt)&quot;);&#10;        }&#10;                    Console.WriteLine($&quot;Running STRING benchmarks with {priority} priority...&quot;);&#10;                    var stringBenchmarks = new StringBenchmarks();&#10;                    stringBenchmarks.RunManual(priority);&#10;                    Console.WriteLine(&quot;✓ String benchmarks completed!&quot;);&#10;                    Console.WriteLine($&quot;Results saved to: result/detailed_results_string_{priority}.txt&quot;);&#10;        {&#10;            Console.WriteLine(&quot;=== Running Collection Performance Benchmarks ===&quot;);&#10;            Console.WriteLine($&quot;The process will be configured with {priority.ToUpper()} priority:&quot;);&#10;                    Console.WriteLine($&quot;Running GUID benchmarks with {priority} priority...&quot;);&#10;                    var guidBenchmarks = new GuidBenchmarks();&#10;                    guidBenchmarks.RunManual(priority);&#10;                    Console.WriteLine(&quot;✓ GUID benchmarks completed!&quot;);&#10;                    Console.WriteLine($&quot;Results saved to: result/detailed_results_guid_{priority}.txt&quot;);&#10;            Console.WriteLine(&quot;• Multiple iterations with statistical analysis&quot;);&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;This may take several minutes to complete...&quot;);&#10;                    Console.WriteLine($&quot;Running ALL benchmark types with {priority} priority...&quot;);&#10;&#10;            switch (dataType)&#10;                    allIntBenchmarks.RunManual(priority);&#10;                    Console.WriteLine(&quot;✓ Integer benchmarks completed!&quot;);&#10;&#10;                case &quot;int&quot;:&#10;                    var allStringBenchmarks = new StringBenchmarks();&#10;                    allStringBenchmarks.RunManual(priority);&#10;                    Console.WriteLine(&quot;✓ String benchmarks completed!&quot;);&#10;&#10;                case &quot;&quot;:&#10;                    var allGuidBenchmarks = new GuidBenchmarks();&#10;                    allGuidBenchmarks.RunManual(priority);&#10;                    Console.WriteLine(&quot;✓ GUID benchmarks completed!&quot;);&#10;&#10;                    Console.WriteLine(&quot;\n✓ All benchmarks completed successfully!&quot;);&#10;                    Console.WriteLine($&quot;Results saved to result/ directory with _{priority} suffix&quot;);&#10;                    var intBenchmarks = new IntegerBenchmarks();&#10;                    intBenchmarks.RunManual(priority);&#10;                    Console.WriteLine(&quot;✓ Integer benchmarks completed!&quot;);&#10;                    Console.WriteLine($&quot;Results saved to: result/detailed_results_integer_{priority}.txt&quot;);&#10;                    break;&#10;                    Console.WriteLine(&quot;Available priorities: normal, high, realtime&quot;);&#10;                    &#10;                    return;&#10;                case &quot;str&quot;:&#10;&#10;            Console.WriteLine();&#10;            Console.WriteLine($&quot;Run 'dotnet run -c Release analyze {dataType} {priority}' to generate statistical analysis.&quot;);&#10;                    Console.WriteLine($&quot;Running STRING benchmarks with {priority} priority...&quot;);&#10;                    var stringBenchmarks = new StringBenchmarks();&#10;        private static string GetPriorityDescription(string priority)&#10;        {&#10;            return priority.ToLower() switch&#10;            {&#10;                &quot;normal&quot; =&gt; &quot;Normal process priority for standard testing&quot;,&#10;                &quot;high&quot; =&gt; &quot;High process priority for reduced interference&quot;,&#10;                &quot;realtime&quot; =&gt; &quot;RealTime priority for maximum consistency&quot;,&#10;                _ =&gt; &quot;Normal process priority (default)&quot;&#10;            };&#10;        }&#10;&#10;        private static void RunStatisticalAnalysis(string dataType, string priority)&#10;                    Console.WriteLine(&quot;✓ String benchmarks completed!&quot;);&#10;                    Console.WriteLine($&quot;Results saved to: result/detailed_results_string_{priority}.txt&quot;);&#10;                    break;&#10;&#10;                case &quot;guid&quot;:&#10;            // Determine file paths based on data type and priority&#10;            string resultsFileName, summaryFileName, reportFileName, dataTypeName;&#10;                    guidBenchmarks.RunManual(priority);&#10;                    Console.WriteLine(&quot;✓ GUID benchmarks completed!&quot;);&#10;                    Console.WriteLine($&quot;Results saved to: result/detailed_results_guid_{priority}.txt&quot;);&#10;                    break;&#10;                    resultsFileName = $&quot;detailed_results_string_{priority}.txt&quot;;&#10;                    summaryFileName = $&quot;statistical_summary_string_{priority}.csv&quot;;&#10;                    reportFileName = $&quot;performance_report_string_{priority}.md&quot;;&#10;                    dataTypeName = &quot;STRING&quot;;&#10;                    var allIntBenchmarks = new IntegerBenchmarks();&#10;                    allIntBenchmarks.RunManual(priority);&#10;                    Console.WriteLine(&quot;✓ Integer benchmarks completed!&quot;);&#10;                    resultsFileName = $&quot;detailed_results_guid_{priority}.txt&quot;;&#10;                    summaryFileName = $&quot;statistical_summary_guid_{priority}.csv&quot;;&#10;                    reportFileName = $&quot;performance_report_guid_{priority}.md&quot;;&#10;                    dataTypeName = &quot;GUID&quot;;&#10;                    Console.WriteLine(&quot;✓ String benchmarks completed!&quot;);&#10;                    &#10;                    Console.WriteLine(&quot;\n3/3 Running GUID benchmarks...&quot;);&#10;                    var allGuidBenchmarks = new GuidBenchmarks();&#10;                    allGuidBenchmarks.RunManual(priority);&#10;                    resultsFileName = $&quot;detailed_results_integer_{priority}.txt&quot;;&#10;                    summaryFileName = $&quot;statistical_summary_integer_{priority}.csv&quot;;&#10;                    reportFileName = $&quot;performance_report_integer_{priority}.md&quot;;&#10;                    dataTypeName = &quot;INTEGER&quot;;&#10;                    break;&#10;                    &#10;                default:&#10;            // Get the project directory (4 levels up from bin/Release/net9.0)&#10;            var projectDirectory = Directory.GetParent(AppDomain.CurrentDomain.BaseDirectory)?.Parent?.Parent?.Parent?.FullName&#10;                                 ?? AppDomain.CurrentDomain.BaseDirectory;&#10;            var baseDirectory = Path.Combine(projectDirectory, &quot;result&quot;);&#10;            var resultsPath = Path.Combine(baseDirectory, resultsFileName);&#10;            var summaryPath = Path.Combine(baseDirectory, summaryFileName);&#10;            var reportPath = Path.Combine(baseDirectory, reportFileName);&#10;                    ShowHelp();&#10;            Console.WriteLine($&quot;Analyzing {dataTypeName} benchmark results with {priority.ToUpper()} priority...&quot;);&#10;                    return;&#10;            }&#10;            &#10;            Console.WriteLine();&#10;            Console.WriteLine($&quot;Run 'dotnet run -c Release analyze {dataType} {priority}' to generate statistical analysis.&quot;);&#10;        }&#10;&#10;                Console.WriteLine($&quot;No {dataType} results with {priority} priority found. Make sure the {resultsFileName} file exists and contains data.&quot;);&#10;                Console.WriteLine($&quot;Run 'dotnet run -c Release benchmark {dataType} {priority}' first to generate benchmark data.&quot;);&#10;            return priority.ToLower() switch&#10;            {&#10;                &quot;normal&quot; =&gt; &quot;Normal process priority for standard testing&quot;,&#10;                &quot;high&quot; =&gt; &quot;High process priority for reduced interference&quot;,&#10;                &quot;realtime&quot; =&gt; &quot;RealTime priority for maximum consistency&quot;,&#10;                _ =&gt; &quot;Normal process priority (default)&quot;&#10;            };&#10;        }&#10;&#10;        private static void RunStatisticalAnalysis(string dataType, string priority)&#10;        {&#10;            Console.WriteLine(&quot;=== Benchmark Result Statistical Analysis ===&quot;);&#10;            &#10;            var analyzer = new BenchmarkResultAnalyzer();&#10;            &#10;            // Determine file paths based on data type and priority&#10;            string resultsFileName, summaryFileName, reportFileName, dataTypeName;&#10;            switch (dataType)&#10;            {&#10;                case &quot;string&quot;:&#10;                case &quot;str&quot;:&#10;                    resultsFileName = $&quot;detailed_results_string_{priority}.txt&quot;;&#10;                    summaryFileName = $&quot;statistical_summary_string_{priority}.csv&quot;;&#10;                    reportFileName = $&quot;performance_report_string_{priority}.md&quot;;&#10;                    dataTypeName = &quot;STRING&quot;;&#10;                    break;&#10;&#10;                case &quot;guid&quot;:&#10;                Console.WriteLine($&quot;\nTop 3 performers for N=10,000, Lookups=10,000 with {priority} priority:&quot;);&#10;                    summaryFileName = $&quot;statistical_summary_guid_{priority}.csv&quot;;&#10;                    reportFileName = $&quot;performance_report_guid_{priority}.md&quot;;&#10;                    dataTypeName = &quot;GUID&quot;;&#10;                    break;&#10;                    &#10;                case &quot;int&quot;:&#10;                case &quot;integer&quot;:&#10;                default:&#10;                    resultsFileName = $&quot;detailed_results_integer_{priority}.txt&quot;;&#10;                    summaryFileName = $&quot;statistical_summary_integer_{priority}.csv&quot;;&#10;                    reportFileName = $&quot;performance_report_integer_{priority}.md&quot;;&#10;&#10;        private static void RunFullBenchmarkAndAnalysis(string dataType, string priority)&#10;        {&#10;            Console.WriteLine(&quot;=== Full Benchmark Execution: Benchmarks + Analysis ===&quot;);&#10;            Console.WriteLine();&#10;&#10;            // Run benchmarks first&#10;            Console.WriteLine(&quot;Step 1/2: Running benchmarks...&quot;);&#10;            RunBenchmarks(dataType, priority);&#10;&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;Step 2/2: Analyzing results...&quot;);&#10;            RunStatisticalAnalysis(dataType, priority);&#10;&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;✓ Full benchmark and analysis completed!&quot;);&#10;        }&#10;                    dataTypeName = &quot;INTEGER&quot;;&#10;                    break;&#10;            }&#10;            &#10;            // Get the project directory (4 levels up from bin/Release/net9.0)&#10;            var projectDirectory = Directory.GetParent(AppDomain.CurrentDomain.BaseDirectory)?.Parent?.Parent?.Parent?.FullName &#10;                                 ?? AppDomain.CurrentDomain.BaseDirectory;&#10;            var baseDirectory = Path.Combine(projectDirectory, &quot;result&quot;);&#10;            var resultsPath = Path.Combine(baseDirectory, resultsFileName);&#10;            var summaryPath = Path.Combine(baseDirectory, summaryFileName);&#10;            var reportPath = Path.Combine(baseDirectory, reportFileName);&#10;            &#10;            Console.WriteLine($&quot;Analyzing {dataTypeName} benchmark results with {priority.ToUpper()} priority...&quot;);&#10;            Console.WriteLine($&quot;Reading results from: {resultsPath}&quot;);&#10;            &#10;            // Read the benchmark results&#10;            var results = analyzer.ReadResults(resultsPath);&#10;            &#10;            if (results.Count == 0)&#10;            {&#10;                Console.WriteLine($&quot;No {dataType} results with {priority} priority found. Make sure the {resultsFileName} file exists and contains data.&quot;);&#10;                Console.WriteLine($&quot;Run 'dotnet run -c Release benchmark {dataType} {priority}' first to generate benchmark data.&quot;);&#10;                return;&#10;            }&#10;            &#10;            Console.WriteLine($&quot;Loaded {results.Count} benchmark results&quot;);&#10;            &#10;            // Analyze with outlier removal (Z-score threshold of 2.0)&#10;            Console.WriteLine(&quot;Performing statistical analysis with outlier detection...&quot;);&#10;            var summaries = analyzer.AnalyzeResults(results, outlierThreshold: 2.0);&#10;            &#10;            Console.WriteLine($&quot;Generated {summaries.Count} statistical summaries&quot;);&#10;            &#10;            // Write statistical summary to CSV&#10;            analyzer.WriteSummaryToFile(summaries, summaryPath);&#10;            &#10;            // Generate performance report&#10;            analyzer.GeneratePerformanceReport(summaries, reportPath);&#10;            &#10;            // Display some quick stats&#10;            Console.WriteLine(&quot;\n=== Quick Overview ===&quot;);&#10;            var totalOutliers = summaries.Sum(s =&gt; s.OutliersRemoved);&#10;            var totalSamples = summaries.Sum(s =&gt; s.SampleCount);&#10;            Console.WriteLine($&quot;Total samples analyzed: {totalSamples}&quot;);&#10;            Console.WriteLine($&quot;Total outliers removed: {totalOutliers} ({(double)totalOutliers/totalSamples*100:F1}%)&quot;);&#10;            &#10;            // Show top performers for largest scenario&#10;            var largestScenario = summaries.Where(s =&gt; s.N == 10000 &amp;&amp; s.LookupCount == 10000).OrderBy(s =&gt; s.TotalMean).Take(3).ToList();&#10;            if (largestScenario.Any())&#10;            {&#10;                Console.WriteLine($&quot;\nTop 3 performers for N=10,000, Lookups=10,000 with {priority} priority:&quot;);&#10;                for (int i = 0; i &lt; largestScenario.Count; i++)&#10;                {&#10;                    var s = largestScenario[i];&#10;                    Console.WriteLine($&quot;{i+1}. {s.CollectionType}: {s.TotalMean:F1} μs (±{s.TotalStdDev:F1})&quot;);&#10;                }&#10;            }&#10;            &#10;            Console.WriteLine($&quot;\nFiles generated:&quot;);&#10;            Console.WriteLine($&quot;- Statistical Summary: {summaryPath}&quot;);&#10;            Console.WriteLine($&quot;- Performance Report: {reportPath}&quot;);&#10;        }&#10;        &#10;        private static void RunFullBenchmarkAndAnalysis(string dataType, string priority)&#10;        {&#10;            Console.WriteLine(&quot;=== Full Benchmark Execution: Benchmarks + Analysis ===&quot;);&#10;            Console.WriteLine();&#10;            &#10;            // Run benchmarks first&#10;            Console.WriteLine(&quot;Step 1/2: Running benchmarks...&quot;);&#10;            RunBenchmarks(dataType, priority);&#10;            &#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;Step 2/2: Analyzing results...&quot;);&#10;            RunStatisticalAnalysis(dataType, priority);&#10;            &#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;✓ Full benchmark and analysis completed!&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#13;&#10;using System.IO;&#13;&#10;using System.Linq;&#13;&#10;using BenchmarkDotNet.Running;&#13;&#10;&#13;&#10;namespace Benchmarks&#13;&#10;{&#13;&#10;    public class Program&#13;&#10;    {&#13;&#10;        public static void Main(string[] args)&#13;&#10;        {&#13;&#10;            if (args.Length == 0)&#13;&#10;            {&#13;&#10;                ShowHelp();&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            var command = args[0].ToLower();&#13;&#10;&#13;&#10;            switch (command)&#13;&#10;            {&#13;&#10;                case &quot;benchmark&quot;:&#13;&#10;                case &quot;bench&quot;:&#13;&#10;                case &quot;b&quot;:&#13;&#10;                    var dataType = args.Length &gt; 1 ? args[1].ToLower() : &quot;&quot;;&#13;&#10;                    RunBenchmarks(dataType);&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                case &quot;analyze&quot;:&#13;&#10;                case &quot;analysis&quot;:&#13;&#10;                case &quot;a&quot;:&#13;&#10;                case &quot;summary&quot;:&#13;&#10;                case &quot;sum&quot;:&#13;&#10;                case &quot;s&quot;:&#13;&#10;                    var analyzeDataType = args.Length &gt; 1 ? args[1].ToLower() : &quot;int&quot;;&#13;&#10;                    RunStatisticalAnalysis(analyzeDataType);&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                case &quot;help&quot;:&#13;&#10;                case &quot;h&quot;:&#13;&#10;                case &quot;?&quot;:&#13;&#10;                    ShowHelp();&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                default:&#13;&#10;                    Console.WriteLine($&quot;Unknown command: {command}&quot;);&#13;&#10;                    ShowHelp();&#13;&#10;                    break;&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        private static void ShowHelp()&#13;&#10;        {&#13;&#10;            Console.WriteLine(&quot;=== C# Collection Performance Benchmarks ===&quot;);&#13;&#10;            Console.WriteLine();&#13;&#10;            Console.WriteLine(&quot;Usage: dotnet run -c Release &lt;command&gt; [datatype]&quot;);&#13;&#10;            Console.WriteLine();&#13;&#10;            Console.WriteLine(&quot;Commands:&quot;);&#13;&#10;            Console.WriteLine(&quot;  benchmark, bench, b    - Run performance benchmarks (30 iterations each)&quot;);&#13;&#10;            Console.WriteLine(&quot;  analyze, analysis, a   - Analyze existing results with statistics&quot;);&#13;&#10;            Console.WriteLine(&quot;  summary, sum, s        - Same as analyze (alias)&quot;);&#13;&#10;            Console.WriteLine(&quot;  help, h, ?            - Show this help message&quot;);&#13;&#10;            Console.WriteLine();&#13;&#10;            Console.WriteLine(&quot;Data Types:&quot;);&#13;&#10;            Console.WriteLine(&quot;  int, integer          - Integer benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  string, str           - String benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  guid                  - GUID benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  all                   - All data types&quot;);&#13;&#10;            Console.WriteLine();&#13;&#10;            Console.WriteLine(&quot;Examples:&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark int       # Run integer benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark string     # Run string benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark guid       # Run GUID benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark all        # Run all benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release analyze int          # Analyze integer results&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release analyze string       # Analyze string results&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release analyze guid         # Analyze GUID results&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release summary guid         # Same as analyze guid&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release b guid               # Short form benchmark&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release s guid               # Short form summary/analyze&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        private static void RunBenchmarks(string dataType)&#13;&#10;        {&#13;&#10;            Console.WriteLine(&quot;=== Running Performance Benchmarks ===&quot;);&#13;&#10;            Console.WriteLine(&quot;This will run collection benchmarks with detailed timing measurements.&quot;);&#13;&#10;            Console.WriteLine(&quot;This may take several minutes to complete...&quot;);&#13;&#10;            Console.WriteLine();&#13;&#10;&#13;&#10;            switch (dataType)&#13;&#10;            {&#13;&#10;                case &quot;int&quot;:&#13;&#10;                case &quot;integer&quot;:&#13;&#10;                case &quot;&quot;:&#13;&#10;                    Console.WriteLine(&quot;Running INTEGER benchmarks...&quot;);&#13;&#10;                    var intBenchmarks = new IntegerBenchmarks();&#13;&#10;                    intBenchmarks.RunManual();&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                case &quot;string&quot;:&#13;&#10;                case &quot;str&quot;:&#13;&#10;                    Console.WriteLine(&quot;Running STRING benchmarks...&quot;);&#13;&#10;                    BenchmarkRunner.Run&lt;StringBenchmarks&gt;();&#13;&#10;                    break;&#13;&#10;&#13;&#10;                case &quot;guid&quot;:&#13;&#10;                    Console.WriteLine(&quot;Running GUID benchmarks...&quot;);&#13;&#10;                    BenchmarkRunner.Run&lt;GuidBenchmarks&gt;();&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                case &quot;all&quot;:&#13;&#10;                    Console.WriteLine(&quot;Running ALL benchmark types...&quot;);&#13;&#10;                    Console.WriteLine(&quot;\n1/3 Running INTEGER benchmarks...&quot;);&#13;&#10;                    var allIntBenchmarks = new IntegerBenchmarks();&#13;&#10;                    allIntBenchmarks.RunManual();&#13;&#10;                    Console.WriteLine(&quot;\n2/3 Running STRING benchmarks...&quot;);&#13;&#10;                    BenchmarkRunner.Run&lt;StringBenchmarks&gt;();&#13;&#10;                    Console.WriteLine(&quot;\n3/3 Running GUID benchmarks...&quot;);&#13;&#10;                    BenchmarkRunner.Run&lt;GuidBenchmarks&gt;();&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                default:&#13;&#10;                    Console.WriteLine($&quot;Unknown data type: {dataType}&quot;);&#13;&#10;                    Console.WriteLine(&quot;Available types: int, string, guid, all&quot;);&#13;&#10;                    ShowHelp();&#13;&#10;                    break;&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        private static void RunStatisticalAnalysis(string dataType)&#13;&#10;        {&#13;&#10;            Console.WriteLine(&quot;=== Benchmark Result Statistical Analysis ===&quot;);&#13;&#10;            &#13;&#10;            var analyzer = new BenchmarkResultAnalyzer();&#13;&#10;            &#13;&#10;            // Determine file paths based on data type&#13;&#10;            string resultsFileName, summaryFileName, reportFileName;&#13;&#10;            switch (dataType)&#13;&#10;            {&#13;&#10;                case &quot;string&quot;:&#13;&#10;                case &quot;str&quot;:&#13;&#10;                    resultsFileName = &quot;detailed_results_string.txt&quot;;&#13;&#10;                    summaryFileName = &quot;statistical_summary_string.csv&quot;;&#13;&#10;                    reportFileName = &quot;performance_report_string.md&quot;;&#13;&#10;                    Console.WriteLine(&quot;Analyzing STRING benchmark results...&quot;);&#13;&#10;                    break;&#13;&#10;&#13;&#10;                case &quot;guid&quot;:&#13;&#10;                    resultsFileName = &quot;detailed_results_guid.txt&quot;;&#13;&#10;                    summaryFileName = &quot;statistical_summary_guid.csv&quot;;&#13;&#10;                    reportFileName = &quot;performance_report_guid.md&quot;;&#13;&#10;                    Console.WriteLine(&quot;Analyzing GUID benchmark results...&quot;);&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                case &quot;int&quot;:&#13;&#10;                case &quot;integer&quot;:&#13;&#10;                default:&#13;&#10;                    resultsFileName = &quot;detailed_results_integer.txt&quot;;&#13;&#10;                    summaryFileName = &quot;statistical_summary_integer.csv&quot;;&#13;&#10;                    reportFileName = &quot;performance_report_integer.md&quot;;&#13;&#10;                    Console.WriteLine(&quot;Analyzing INTEGER benchmark results...&quot;);&#13;&#10;                    break;&#13;&#10;            }&#13;&#10;            &#13;&#10;            var resultsPath = Path.Combine(Environment.CurrentDirectory, &quot;BenchmarkDotNet.Artifacts&quot;, resultsFileName);&#13;&#10;            var summaryPath = Path.Combine(Environment.CurrentDirectory, &quot;BenchmarkDotNet.Artifacts&quot;, summaryFileName);&#13;&#10;            var reportPath = Path.Combine(Environment.CurrentDirectory, &quot;BenchmarkDotNet.Artifacts&quot;, reportFileName);&#13;&#10;            &#13;&#10;            Console.WriteLine($&quot;Reading results from: {resultsPath}&quot;);&#13;&#10;            &#13;&#10;            // Read the benchmark results&#13;&#10;            var results = analyzer.ReadResults(resultsPath);&#13;&#10;            &#13;&#10;            if (results.Count == 0)&#13;&#10;            {&#13;&#10;                Console.WriteLine($&quot;No {dataType} results found. Make sure the {resultsFileName} file exists and contains data.&quot;);&#13;&#10;                Console.WriteLine($&quot;Run 'dotnet run -c Release benchmark {dataType}' first to generate benchmark data.&quot;);&#13;&#10;                return;&#13;&#10;            }&#13;&#10;            &#13;&#10;            Console.WriteLine($&quot;Loaded {results.Count} benchmark results&quot;);&#13;&#10;            &#13;&#10;            // Analyze with outlier removal (Z-score threshold of 2.0)&#13;&#10;            Console.WriteLine(&quot;Performing statistical analysis with outlier detection...&quot;);&#13;&#10;            var summaries = analyzer.AnalyzeResults(results, outlierThreshold: 2.0);&#13;&#10;            &#13;&#10;            Console.WriteLine($&quot;Generated {summaries.Count} statistical summaries&quot;);&#13;&#10;            &#13;&#10;            // Write statistical summary to CSV&#13;&#10;            analyzer.WriteSummaryToFile(summaries, summaryPath);&#13;&#10;            &#13;&#10;            // Generate performance report&#13;&#10;            analyzer.GeneratePerformanceReport(summaries, reportPath);&#13;&#10;            &#13;&#10;            // Display some quick stats&#13;&#10;            Console.WriteLine(&quot;\n=== Quick Overview ===&quot;);&#13;&#10;            var totalOutliers = summaries.Sum(s =&gt; s.OutliersRemoved);&#13;&#10;            var totalSamples = summaries.Sum(s =&gt; s.SampleCount);&#13;&#10;            Console.WriteLine($&quot;Total samples analyzed: {totalSamples}&quot;);&#13;&#10;            Console.WriteLine($&quot;Total outliers removed: {totalOutliers} ({(double)totalOutliers/totalSamples*100:F1}%)&quot;);&#13;&#10;            &#13;&#10;            // Show top performers for largest scenario&#13;&#10;            var largestScenario = summaries.Where(s =&gt; s.N == 10000 &amp;&amp; s.LookupCount == 10000).OrderBy(s =&gt; s.TotalMean).Take(3).ToList();&#13;&#10;            if (largestScenario.Any())&#13;&#10;            {&#13;&#10;                Console.WriteLine(&quot;\nTop 3 performers for N=10,000, Lookups=10,000:&quot;);&#13;&#10;                for (int i = 0; i &lt; largestScenario.Count; i++)&#13;&#10;                {&#13;&#10;                    var s = largestScenario[i];&#13;&#10;                    Console.WriteLine($&quot;{i+1}. {s.CollectionType}: {s.TotalMean:F1} μs (±{s.TotalStdDev:F1})&quot;);&#13;&#10;                }&#13;&#10;            }&#13;&#10;            &#13;&#10;            Console.WriteLine($&quot;\nFiles generated:&quot;);&#13;&#10;            Console.WriteLine($&quot;- Statistical Summary: {summaryPath}&quot;);&#13;&#10;            Console.WriteLine($&quot;- Performance Report: {reportPath}&quot;);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/StringCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/StringCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class StringCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringDictionary_CreationAndLookup()&#10;        {&#10;            var collection = stringSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringSortedDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new SortedDictionary&lt;string, bool&gt;(stringSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>