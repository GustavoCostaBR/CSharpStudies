<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="originalContent" value="# Build results&#10;[Dd]ebug/&#10;[Dd]ebugPublic/&#10;[Rr]elease/&#10;[Rr]eleases/&#10;x64/&#10;x86/&#10;[Ww][Ii][Nn]32/&#10;[Aa][Rr][Mm]/&#10;[Aa][Rr][Mm]64/&#10;bld/&#10;[Bb]in/&#10;[Oo]bj/&#10;[Ll]og/&#10;[Ll]ogs/&#10;&#10;# Visual Studio 2015/2017 cache/options directory&#10;.vs/&#10;# Uncomment if you have tasks that create the project's static files in wwwroot&#10;#wwwroot/&#10;&#10;# Visual Studio 2017 auto generated files&#10;Generated\ Files/&#10;&#10;# MSTest test Results&#10;[Tt]est[Rr]esult*/&#10;[Bb]uild[Ll]og.*&#10;&#10;# NUnit&#10;*.VisualState.xml&#10;TestResult.xml&#10;nunit-*.xml&#10;&#10;# Build Results of an ATL Project&#10;[Dd]ebugPS/&#10;[Rr]eleasePS/&#10;dlldata.c&#10;&#10;# Benchmark Results&#10;BenchmarkDotNet.Artifacts/&#10;&#10;# .NET Core&#10;project.lock.json&#10;project.fragment.lock.json&#10;artifacts/&#10;&#10;# StyleCop&#10;StyleCopReport.xml&#10;&#10;# Files built by Visual Studio&#10;*_i.c&#10;*_p.c&#10;*_h.h&#10;*.ilk&#10;*.meta&#10;*.obj&#10;*.iobj&#10;*.pch&#10;*.pdb&#10;*.ipdb&#10;*.pgc&#10;*.pgd&#10;*.rsp&#10;*.sbr&#10;*.tlb&#10;*.tli&#10;*.tlh&#10;*.tmp&#10;*.tmp_proj&#10;*_wpftmp.csproj&#10;*.log&#10;*.vspscc&#10;*.vssscc&#10;.builds&#10;*.pidb&#10;*.svclog&#10;*.scc&#10;&#10;# Chutzpah Test files&#10;_Chutzpah*&#10;&#10;# Visual C++ cache files&#10;ipch/&#10;*.aps&#10;*.ncb&#10;*.opendb&#10;*.opensdf&#10;*.sdf&#10;*.cachefile&#10;*.VC.db&#10;*.VC.VC.opendb&#10;&#10;# Visual Studio profiler&#10;*.psess&#10;*.vsp&#10;*.vspx&#10;*.sap&#10;&#10;# Visual Studio Trace Files&#10;*.e2e&#10;&#10;# TFS 2012 Local Workspace&#10;$tf/&#10;&#10;# Guidance Automation Toolkit&#10;*.gpState&#10;&#10;# ReSharper is a .NET coding add-in&#10;_ReSharper*/&#10;*.[Rr]e[Ss]harper&#10;*.DotSettings.user&#10;&#10;# TeamCity is a build add-in&#10;_TeamCity*&#10;&#10;# DotCover is a Code Coverage Tool&#10;*.dotCover&#10;&#10;# AxoCover is a Code Coverage Tool&#10;.axoCover/*&#10;!.axoCover/settings.json&#10;&#10;# Coverlet is a free, cross platform Code Coverage Tool&#10;coverage*.json&#10;coverage*.xml&#10;coverage*.info&#10;&#10;# Visual Studio code coverage results&#10;*.coverage&#10;*.coveragexml&#10;&#10;# NCrunch&#10;_NCrunch_*&#10;.*crunch*.local.xml&#10;nCrunchTemp_*&#10;&#10;# MightyMoose&#10;*.mm.*&#10;AutoTest.Net/&#10;&#10;# Web workbench (sass)&#10;.sass-cache/&#10;&#10;# Installshield output folder&#10;[Ee]xpress/&#10;&#10;# DocProject is a documentation generator add-in&#10;DocProject/buildhelp/&#10;DocProject/Help/*.HxT&#10;DocProject/Help/*.HxC&#10;DocProject/Help/Html2&#10;DocProject/Help/html&#10;&#10;# Click-Once directory&#10;publish/&#10;&#10;# Publish Web Output&#10;*.[Pp]ublish.xml&#10;*.azurePubxml&#10;# Note: Comment the next line if you want to checkin your web deploy settings,&#10;# but database connection strings (with potential passwords) will be unencrypted&#10;*.pubxml&#10;*.publishproj&#10;&#10;# Microsoft Azure Web App publish settings. Comment the next line if you want to&#10;# checkin your Azure Web App publish settings, but sensitive information contained&#10;# in these files may be visible to others.&#10;*.azurePubxml&#10;&#10;# NuGet Packages&#10;*.nupkg&#10;# NuGet Symbol Packages&#10;*.snupkg&#10;# The packages folder can be ignored because of Package Restore&#10;**/[Pp]ackages/*&#10;# except build/, which is used as an MSBuild target.&#10;!**/[Pp]ackages/build/&#10;# Uncomment if necessary however generally it will be regenerated when needed&#10;#!**/[Pp]ackages/repositories.config&#10;# NuGet v3's project.json files produces more ignorable files&#10;*.nuget.props&#10;*.nuget.targets&#10;&#10;# Microsoft Azure Build Output&#10;csx/&#10;*.build.csdef&#10;&#10;# Microsoft Azure Emulator&#10;ecf/&#10;rcf/&#10;&#10;# Windows Store app package directories and files&#10;AppPackages/&#10;BundleArtifacts/&#10;Package.StoreAssociation.xml&#10;_pkginfo.txt&#10;*.appx&#10;*.appxbundle&#10;*.appxupload&#10;&#10;# Visual Studio cache files&#10;# files ending in .cache can be ignored&#10;*.[Cc]ache&#10;# but keep track of directories ending in .cache&#10;!?*.[Cc]ache/&#10;&#10;# Others&#10;ClientBin/&#10;~$*&#10;*~&#10;*.dbmdl&#10;*.dbproj.schemaview&#10;*.jfm&#10;*.pfx&#10;*.publishsettings&#10;orleans.codegen.cs&#10;&#10;# Including strong name files can present a security risk&#10;# (https://github.com/github/gitignore/pull/2483#issue-259490424)&#10;#*.snk&#10;&#10;# Since there are multiple workflows, uncomment the next line to ignore bower_components&#10;# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)&#10;#bower_components/&#10;&#10;# RIA/Silverlight projects&#10;Generated_Code/&#10;&#10;# Backup &amp; report files from converting an old project file&#10;# to a newer Visual Studio version. Backup files are not needed,&#10;# because we have git ;-)&#10;_UpgradeReport_Files/&#10;Backup*/&#10;UpgradeLog*.XML&#10;UpgradeLog*.htm&#10;CConversionReport*&#10;&#10;# SQL Server files&#10;*.mdf&#10;*.ldf&#10;*.ndf&#10;&#10;# Business Intelligence projects&#10;*.rdl.data&#10;*.bim.layout&#10;*.bim_*.settings&#10;*.rptproj.rsuser&#10;*- [Bb]ackup.rdl&#10;*- [Bb]ackup ([0-9]).rdl&#10;*- [Bb]ackup ([0-9][0-9]).rdl&#10;&#10;# Microsoft Fakes&#10;FakesAssemblies/&#10;&#10;# GhostDoc plugin setting file&#10;*.GhostDoc.xml&#10;&#10;# Node.js Tools for Visual Studio&#10;.ntvs_analysis.dat&#10;node_modules/&#10;&#10;# Visual Studio 6 build log&#10;*.plg&#10;&#10;# Visual Studio 6 workspace options file&#10;*.opt&#10;&#10;# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)&#10;*.vbw&#10;&#10;# Visual Studio LightSwitch build output&#10;**/*.HTMLClient/GeneratedArtifacts&#10;**/*.DesktopClient/GeneratedArtifacts&#10;**/*.DesktopClient/ModelManifest.xml&#10;**/*.Server/GeneratedArtifacts&#10;**/*.Server/ModelManifest.xml&#10;_Pvt_Extensions&#10;&#10;# Paket dependency manager&#10;.paket/paket.exe&#10;paket-files/&#10;&#10;# FAKE - F# Make&#10;.fake/&#10;&#10;# CodeRush personal settings&#10;.cr/personal&#10;&#10;# Python Tools for Visual Studio (PTVS)&#10;__pycache__/&#10;*.pyc&#10;&#10;# Cake - Uncomment if you are using it&#10;# tools/**&#10;# !tools/packages.config&#10;&#10;# Tabs Studio&#10;*.tss&#10;&#10;# Telerik's JustMock configuration file&#10;*.jmconfig&#10;&#10;# BizTalk build output&#10;*.btp.cs&#10;*.btm.cs&#10;*.odx.cs&#10;*.xsd.cs&#10;&#10;# OpenCover UI analysis results&#10;OpenCover/&#10;&#10;# Azure Stream Analytics local run output&#10;ASALocalRun/&#10;&#10;# MSBuild Binary and Structured Log&#10;*.binlog&#10;&#10;# NVidia Nsight GPU debugger configuration file&#10;*.nvuser&#10;&#10;# MFractals&#10;*.mfractor/&#10;&#10;# Local History for Visual Studio&#10;.localhistory/&#10;&#10;# BeatPulse healthcheck temp database&#10;healthchecksdb&#10;&#10;# Backup folder for Package Reference Convert tool in Visual Studio 2017&#10;MigrationBackup/&#10;&#10;# Ionide (cross platform F# VS Code tools) working folder&#10;.ionide/&#10;&#10;# Fody - auto-generated XML schema&#10;FodyWeavers.xsd&#10;&#10;# Copilot diff state&#10;copilotDiffState.xml" />
              <option name="updatedContent" value="# Build results&#13;&#10;[Dd]ebug/&#13;&#10;[Dd]ebugPublic/&#13;&#10;[Rr]elease/&#13;&#10;[Rr]eleases/&#13;&#10;x64/&#13;&#10;x86/&#13;&#10;[Ww][Ii][Nn]32/&#13;&#10;[Aa][Rr][Mm]/&#13;&#10;[Aa][Rr][Mm]64/&#13;&#10;bld/&#13;&#10;[Bb]in/&#13;&#10;[Oo]bj/&#13;&#10;[Ll]og/&#13;&#10;[Ll]ogs/&#13;&#10;&#13;&#10;# Visual Studio 2015/2017 cache/options directory&#13;&#10;.vs/&#13;&#10;# Uncomment if you have tasks that create the project's static files in wwwroot&#13;&#10;#wwwroot/&#13;&#10;&#13;&#10;# Visual Studio 2017 auto generated files&#13;&#10;Generated\ Files/&#13;&#10;&#13;&#10;# MSTest test Results&#13;&#10;[Tt]est[Rr]esult*/&#13;&#10;[Bb]uild[Ll]og.*&#13;&#10;&#13;&#10;# NUnit&#13;&#10;*.VisualState.xml&#13;&#10;TestResult.xml&#13;&#10;nunit-*.xml&#13;&#10;&#13;&#10;# Build Results of an ATL Project&#13;&#10;[Dd]ebugPS/&#13;&#10;[Rr]eleasePS/&#13;&#10;dlldata.c&#13;&#10;&#13;&#10;# Benchmark Results&#13;&#10;BenchmarkDotNet.Artifacts/&#13;&#10;&#13;&#10;# .NET Core&#13;&#10;project.lock.json&#13;&#10;project.fragment.lock.json&#13;&#10;artifacts/&#13;&#10;&#13;&#10;# StyleCop&#13;&#10;StyleCopReport.xml&#13;&#10;&#13;&#10;# Files built by Visual Studio&#13;&#10;*_i.c&#13;&#10;*_p.c&#13;&#10;*_h.h&#13;&#10;*.ilk&#13;&#10;*.meta&#13;&#10;*.obj&#13;&#10;*.iobj&#13;&#10;*.pch&#13;&#10;*.pdb&#13;&#10;*.ipdb&#13;&#10;*.pgc&#13;&#10;*.pgd&#13;&#10;*.rsp&#13;&#10;*.sbr&#13;&#10;*.tlb&#13;&#10;*.tli&#13;&#10;*.tlh&#13;&#10;*.tmp&#13;&#10;*.tmp_proj&#13;&#10;*_wpftmp.csproj&#13;&#10;*.log&#13;&#10;*.vspscc&#13;&#10;*.vssscc&#13;&#10;.builds&#13;&#10;*.pidb&#13;&#10;*.svclog&#13;&#10;*.scc&#13;&#10;&#13;&#10;# Chutzpah Test files&#13;&#10;_Chutzpah*&#13;&#10;&#13;&#10;# Visual C++ cache files&#13;&#10;ipch/&#13;&#10;*.aps&#13;&#10;*.ncb&#13;&#10;*.opendb&#13;&#10;*.opensdf&#13;&#10;*.sdf&#13;&#10;*.cachefile&#13;&#10;*.VC.db&#13;&#10;*.VC.VC.opendb&#13;&#10;&#13;&#10;# Visual Studio profiler&#13;&#10;*.psess&#13;&#10;*.vsp&#13;&#10;*.vspx&#13;&#10;*.sap&#13;&#10;&#13;&#10;# Visual Studio Trace Files&#13;&#10;*.e2e&#13;&#10;&#13;&#10;# TFS 2012 Local Workspace&#13;&#10;$tf/&#13;&#10;&#13;&#10;# Guidance Automation Toolkit&#13;&#10;*.gpState&#13;&#10;&#13;&#10;# ReSharper is a .NET coding add-in&#13;&#10;_ReSharper*/&#13;&#10;*.[Rr]e[Ss]harper&#13;&#10;*.DotSettings.user&#13;&#10;&#13;&#10;# TeamCity is a build add-in&#13;&#10;_TeamCity*&#13;&#10;&#13;&#10;# DotCover is a Code Coverage Tool&#13;&#10;*.dotCover&#13;&#10;&#13;&#10;# AxoCover is a Code Coverage Tool&#13;&#10;.axoCover/*&#13;&#10;!.axoCover/settings.json&#13;&#10;&#13;&#10;# Coverlet is a free, cross platform Code Coverage Tool&#13;&#10;coverage*.json&#13;&#10;coverage*.xml&#13;&#10;coverage*.info&#13;&#10;&#13;&#10;# Visual Studio code coverage results&#13;&#10;*.coverage&#13;&#10;*.coveragexml&#13;&#10;&#13;&#10;# NCrunch&#13;&#10;_NCrunch_*&#13;&#10;.*crunch*.local.xml&#13;&#10;nCrunchTemp_*&#13;&#10;&#13;&#10;# MightyMoose&#13;&#10;*.mm.*&#13;&#10;AutoTest.Net/&#13;&#10;&#13;&#10;# Web workbench (sass)&#13;&#10;.sass-cache/&#13;&#10;&#13;&#10;# Installshield output folder&#13;&#10;[Ee]xpress/&#13;&#10;&#13;&#10;# DocProject is a documentation generator add-in&#13;&#10;DocProject/buildhelp/&#13;&#10;DocProject/Help/*.HxT&#13;&#10;DocProject/Help/*.HxC&#13;&#10;DocProject/Help/Html2&#13;&#10;DocProject/Help/html&#13;&#10;&#13;&#10;# Click-Once directory&#13;&#10;publish/&#13;&#10;&#13;&#10;# Publish Web Output&#13;&#10;*.[Pp]ublish.xml&#13;&#10;*.azurePubxml&#13;&#10;# Note: Comment the next line if you want to checkin your web deploy settings,&#13;&#10;# but database connection strings (with potential passwords) will be unencrypted&#13;&#10;*.pubxml&#13;&#10;*.publishproj&#13;&#10;&#13;&#10;# Microsoft Azure Web App publish settings. Comment the next line if you want to&#13;&#10;# checkin your Azure Web App publish settings, but sensitive information contained&#13;&#10;# in these files may be visible to others.&#13;&#10;*.azurePubxml&#13;&#10;&#13;&#10;# NuGet Packages&#13;&#10;*.nupkg&#13;&#10;# NuGet Symbol Packages&#13;&#10;*.snupkg&#13;&#10;# The packages folder can be ignored because of Package Restore&#13;&#10;**/[Pp]ackages/*&#13;&#10;# except build/, which is used as an MSBuild target.&#13;&#10;!**/[Pp]ackages/build/&#13;&#10;# Uncomment if necessary however generally it will be regenerated when needed&#13;&#10;#!**/[Pp]ackages/repositories.config&#13;&#10;# NuGet v3's project.json files produces more ignorable files&#13;&#10;*.nuget.props&#13;&#10;*.nuget.targets&#13;&#10;&#13;&#10;# Microsoft Azure Build Output&#13;&#10;csx/&#13;&#10;*.build.csdef&#13;&#10;&#13;&#10;# Microsoft Azure Emulator&#13;&#10;ecf/&#13;&#10;rcf/&#13;&#10;&#13;&#10;# Windows Store app package directories and files&#13;&#10;AppPackages/&#13;&#10;BundleArtifacts/&#13;&#10;Package.StoreAssociation.xml&#13;&#10;_pkginfo.txt&#13;&#10;*.appx&#13;&#10;*.appxbundle&#13;&#10;*.appxupload&#13;&#10;&#13;&#10;# Visual Studio cache files&#13;&#10;# files ending in .cache can be ignored&#13;&#10;*.[Cc]ache&#13;&#10;# but keep track of directories ending in .cache&#13;&#10;!?*.[Cc]ache/&#13;&#10;&#13;&#10;# Others&#13;&#10;ClientBin/&#13;&#10;~$*&#13;&#10;*~&#13;&#10;*.dbmdl&#13;&#10;*.dbproj.schemaview&#13;&#10;*.jfm&#13;&#10;*.pfx&#13;&#10;*.publishsettings&#13;&#10;orleans.codegen.cs&#13;&#10;&#13;&#10;# Including strong name files can present a security risk&#13;&#10;# (https://github.com/github/gitignore/pull/2483#issue-259490424)&#13;&#10;#*.snk&#13;&#10;&#13;&#10;# Since there are multiple workflows, uncomment the next line to ignore bower_components&#13;&#10;# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)&#13;&#10;#bower_components/&#13;&#10;&#13;&#10;# RIA/Silverlight projects&#13;&#10;Generated_Code/&#13;&#10;&#13;&#10;# Backup &amp; report files from converting an old project file&#13;&#10;# to a newer Visual Studio version. Backup files are not needed,&#13;&#10;# because we have git ;-)&#13;&#10;_UpgradeReport_Files/&#13;&#10;Backup*/&#13;&#10;UpgradeLog*.XML&#13;&#10;UpgradeLog*.htm&#13;&#10;CConversionReport*&#13;&#10;&#13;&#10;# SQL Server files&#13;&#10;*.mdf&#13;&#10;*.ldf&#13;&#10;*.ndf&#13;&#10;&#13;&#10;# Business Intelligence projects&#13;&#10;*.rdl.data&#13;&#10;*.bim.layout&#13;&#10;*.bim_*.settings&#13;&#10;*.rptproj.rsuser&#13;&#10;*- [Bb]ackup.rdl&#13;&#10;*- [Bb]ackup ([0-9]).rdl&#13;&#10;*- [Bb]ackup ([0-9][0-9]).rdl&#13;&#10;&#13;&#10;# Microsoft Fakes&#13;&#10;FakesAssemblies/&#13;&#10;&#13;&#10;# GhostDoc plugin setting file&#13;&#10;*.GhostDoc.xml&#13;&#10;&#13;&#10;# Node.js Tools for Visual Studio&#13;&#10;.ntvs_analysis.dat&#13;&#10;node_modules/&#13;&#10;&#13;&#10;# Visual Studio 6 build log&#13;&#10;*.plg&#13;&#10;&#13;&#10;# Visual Studio 6 workspace options file&#13;&#10;*.opt&#13;&#10;&#13;&#10;# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)&#13;&#10;*.vbw&#13;&#10;&#13;&#10;# Visual Studio LightSwitch build output&#13;&#10;**/*.HTMLClient/GeneratedArtifacts&#13;&#10;**/*.DesktopClient/GeneratedArtifacts&#13;&#10;**/*.DesktopClient/ModelManifest.xml&#13;&#10;**/*.Server/GeneratedArtifacts&#13;&#10;**/*.Server/ModelManifest.xml&#13;&#10;_Pvt_Extensions&#13;&#10;&#13;&#10;# Paket dependency manager&#13;&#10;.paket/paket.exe&#13;&#10;paket-files/&#13;&#10;&#13;&#10;# FAKE - F# Make&#13;&#10;.fake/&#13;&#10;&#13;&#10;# CodeRush personal settings&#13;&#10;.cr/personal&#13;&#10;&#13;&#10;# Python Tools for Visual Studio (PTVS)&#13;&#10;__pycache__/&#13;&#10;*.pyc&#13;&#10;&#13;&#10;# Cake - Uncomment if you are using it&#13;&#10;# tools/**&#13;&#10;# !tools/packages.config&#13;&#10;&#13;&#10;# Tabs Studio&#13;&#10;*.tss&#13;&#10;&#13;&#10;# Telerik's JustMock configuration file&#13;&#10;*.jmconfig&#13;&#10;&#13;&#10;# BizTalk build output&#13;&#10;*.btp.cs&#13;&#10;*.btm.cs&#13;&#10;*.odx.cs&#13;&#10;*.xsd.cs&#13;&#10;&#13;&#10;# OpenCover UI analysis results&#13;&#10;OpenCover/&#13;&#10;&#13;&#10;# Azure Stream Analytics local run output&#13;&#10;ASALocalRun/&#13;&#10;&#13;&#10;# MSBuild Binary and Structured Log&#13;&#10;*.binlog&#13;&#10;&#13;&#10;# NVidia Nsight GPU debugger configuration file&#13;&#10;*.nvuser&#13;&#10;&#13;&#10;# MFractals&#13;&#10;*.mfractor/&#13;&#10;&#13;&#10;# Local History for Visual Studio&#13;&#10;.localhistory/&#13;&#10;&#13;&#10;# BeatPulse healthcheck temp database&#13;&#10;healthchecksdb&#13;&#10;&#13;&#10;# Backup folder for Package Reference Convert tool in Visual Studio 2017&#13;&#10;MigrationBackup/&#13;&#10;&#13;&#10;# Ionide (cross platform F# VS Code tools) working folder&#13;&#10;.ionide/&#13;&#10;&#13;&#10;# Fody - auto-generated XML schema&#13;&#10;FodyWeavers.xsd&#13;&#10;&#13;&#10;# Copilot diff state&#13;&#10;copilotDiffState.xml" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ArrayOperationBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ArrayOperationBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class ArrayOperationBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntArray_IndexOf_Lookup()&#10;        {&#10;            var collection = intSourceData.ToArray();&#10;            foreach (var item in intLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringArray_IndexOf_Lookup()&#10;        {&#10;            var collection = stringSourceData.ToArray();&#10;            foreach (var item in stringLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntArray_BinarySearch_Lookup()&#10;        {&#10;            var collection = intSourceData.ToArray();&#10;            Array.Sort(collection);&#10;            foreach (var item in intLookupItems)&#10;                _ = Array.BinarySearch(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringArray_BinarySearch_Lookup()&#10;        {&#10;            var collection = stringSourceData.ToArray();&#10;            Array.Sort(collection);&#10;            foreach (var item in stringLookupItems)&#10;                _ = Array.BinarySearch(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntArray_Contains_Lookup()&#10;        {&#10;            var collection = intSourceData.ToArray();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringArray_Contains_Lookup()&#10;        {&#10;            var collection = stringSourceData.ToArray();&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ConcurrentCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ConcurrentCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class ConcurrentCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntConcurrentDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentDictionary&lt;int, bool&gt;(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringConcurrentDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentDictionary&lt;string, bool&gt;(stringSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntConcurrentBag_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentBag&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringConcurrentBag_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentBag&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/CustomReferenceTypeBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/CustomReferenceTypeBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    // Custom reference type for testing&#10;    public class Customer : IEquatable&lt;Customer&gt;, IComparable&lt;Customer&gt;&#10;    {&#10;        public string Id { get; }&#10;        public string Name { get; }&#10;        &#10;        public Customer(string id, string name)&#10;        {&#10;            Id = id;&#10;            Name = name;&#10;        }&#10;        &#10;        public bool Equals(Customer? other) =&gt; other != null &amp;&amp; Id == other.Id;&#10;        public override bool Equals(object? obj) =&gt; Equals(obj as Customer);&#10;        public override int GetHashCode() =&gt; Id?.GetHashCode() ?? 0;&#10;        &#10;        public int CompareTo(Customer? other)&#10;        {&#10;            if (other == null) return 1;&#10;            return string.Compare(Id, other.Id, StringComparison.Ordinal);&#10;        }&#10;    }&#10;&#10;    [MemoryDiagnoser]&#10;    public class CustomReferenceTypeBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private Customer[] customerSourceData = null!;&#10;        private Customer[] customerLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            customerSourceData = Enumerable.Range(1, N).Select(i =&gt; new Customer($&quot;CUST_{random.Next()}&quot;, $&quot;Customer {i}&quot;)).ToArray();&#10;            customerLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; new Customer($&quot;CUST_{random.Next()}&quot;, $&quot;Customer {i}&quot;)).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;Customer&gt;(customerSourceData);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;Customer&gt;(customerSourceData);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;Customer&gt;(customerSourceData);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerDictionary_CreationAndLookup()&#10;        {&#10;            var collection = customerSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/CustomValueTypeBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/CustomValueTypeBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    // Custom value type for testing&#10;    public struct ProductId : IEquatable&lt;ProductId&gt;, IComparable&lt;ProductId&gt;&#10;    {&#10;        public int Value { get; }&#10;        &#10;        public ProductId(int value) =&gt; Value = value;&#10;        &#10;        public bool Equals(ProductId other) =&gt; Value == other.Value;&#10;        public override bool Equals(object? obj) =&gt; obj is ProductId other &amp;&amp; Equals(other);&#10;        public override int GetHashCode() =&gt; Value.GetHashCode();&#10;        public static implicit operator ProductId(int value) =&gt; new(value);&#10;        &#10;        public int CompareTo(ProductId other) =&gt; Value.CompareTo(other.Value);&#10;    }&#10;&#10;    [MemoryDiagnoser]&#10;    public class CustomValueTypeBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private ProductId[] productIdSourceData = null!;&#10;        private ProductId[] productIdLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            productIdSourceData = Enumerable.Range(1, N).Select(i =&gt; new ProductId(random.Next())).Distinct().Take(N).ToArray();&#10;            productIdLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; new ProductId(random.Next())).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;ProductId&gt;(productIdSourceData);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;ProductId&gt;(productIdSourceData);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;ProductId&gt;(productIdSourceData);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdDictionary_CreationAndLookup()&#10;        {&#10;            var collection = productIdSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/GuidCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/GuidCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class GuidCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private Guid[] guidSourceData = null!;&#10;        private Guid[] guidLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            guidSourceData = Enumerable.Range(1, N).Select(i =&gt; Guid.NewGuid()).ToArray();&#10;            guidLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; Guid.NewGuid()).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;Guid&gt;(guidSourceData);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;Guid&gt;(guidSourceData);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;Guid&gt;(guidSourceData);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidDictionary_CreationAndLookup()&#10;        {&#10;            var collection = guidSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidSortedDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new SortedDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ImmutableCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ImmutableCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class ImmutableCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableList_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableList.CreateRange(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableHashSet_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableHashSet.CreateRange(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableSortedSet.CreateRange(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringImmutableList_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableList.CreateRange(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringImmutableHashSet_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableHashSet.CreateRange(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableDictionary_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableDictionary.CreateRange(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/IntegerBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/IntegerBenchmarks.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.Diagnostics;&#10;using System.IO;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;&#10;namespace Benchmarks&#10;{&#10;    public class IntegerBenchmarks&#10;    {&#10;        // Benchmark iteration constants&#10;        public const int WarmupIterations = 5;&#10;        public const int ActualIterations = 50;&#10;&#10;        private int N { get; set; }&#10;        private int LookupCount { get; set; }&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private static readonly object _fileLock = new object();&#10;        private int _iterationCount = 0;&#10;&#10;        public void RunManual()&#10;        {&#10;            var nValues = new[] { 10, 100, 1000, 10000 };&#10;            var lookupValues = new[] { 10, 100, 1000, 10000 };&#10;&#10;            foreach (var n in nValues)&#10;            {&#10;                foreach (var lookupCount in lookupValues)&#10;                {&#10;                    N = n;&#10;                    LookupCount = lookupCount;&#10;                    &#10;                    Console.WriteLine($&quot;\nRunning for N={N}, LookupCount={LookupCount}&quot;);&#10;                    &#10;                    Setup();&#10;                    &#10;                    _iterationCount = 0;&#10;                    &#10;                    for (int i = 0; i &lt; WarmupIterations + ActualIterations; i++)&#10;                    {&#10;                        IterationSetup();&#10;                        &#10;                        IntList();&#10;                        IntHashSet();&#10;                        IntSortedSet();&#10;                        IterationCleanup();&#10;                        &#10;                        IntDictionary();&#10;                        IntSortedDictionary();&#10;                        IntConcurrentDictionary();&#10;                        IntImmutableList();&#10;                        IntImmutableHashSet();&#10;                        IntArray();&#10;                        &#10;                        IterationCleanup();&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;        }&#10;&#10;        public void IterationSetup()&#10;        {&#10;            _iterationCount++;&#10;        }&#10;&#10;        private void LogDetailedResults(string collectionType, int n, int lookupCount, TimeSpan creationTime, TimeSpan lookupTime, TimeSpan totalTime)&#10;        {&#10;            // Only log results after warmup iterations are complete&#10;            if (_iterationCount &lt;= WarmupIterations)&#10;            {&#10;                return; // Skip logging during warmup&#10;            }&#10;&#10;            // Use a hardcoded absolute path to ensure we can find it&#10;            var logPath = @&quot;C:\Users\Gustavo\Documents\Projetos\Estudos_Csharp\CSharpStudies\Topic6\Benchmarks\BenchmarkDotNet.Artifacts\detailed_results_integer.txt&quot;;&#10;            &#10;            // Ensure directory exists&#10;            Directory.CreateDirectory(Path.GetDirectoryName(logPath));&#10;            &#10;            lock (_fileLock)&#10;            {&#10;                try&#10;                {&#10;                    // Check if we need to write header BEFORE opening the file&#10;                    bool needsHeader = !File.Exists(logPath) || new FileInfo(logPath).Length == 0;&#10;                    &#10;                    using var writer = new StreamWriter(logPath, true);&#10;                    if (needsHeader)&#10;                    {&#10;                        // Write header if file doesn't exist or is empty&#10;                        writer.WriteLine(&quot;CollectionType,N,LookupCount,CreationTime_μs,LookupTime_μs,TotalTime_μs&quot;);&#10;                    }&#10;                    writer.WriteLine($&quot;{collectionType},{n},{lookupCount},{creationTime.TotalMicroseconds:F2},{lookupTime.TotalMicroseconds:F2},{totalTime.TotalMicroseconds:F2}&quot;);&#10;                    &#10;                    // Force write to disk&#10;                    writer.Flush();&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    // If there's an issue, write to a backup location we can debug&#10;                    var backupPath = @&quot;C:\temp\benchmark_debug_integer.txt&quot;;&#10;                    Directory.CreateDirectory(Path.GetDirectoryName(backupPath));&#10;                    File.AppendAllText(backupPath, $&quot;ERROR: {ex.Message}\n&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        public void IterationCleanup()&#10;        {&#10;            // Force garbage collection between iterations to prevent memory pressure interference&#10;            GC.Collect();&#10;            GC.WaitForPendingFinalizers();&#10;            GC.Collect();&#10;        }&#10;&#10;        public void IntList()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new List&lt;int&gt;(intSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;List&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntHashSet()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new HashSet&lt;int&gt;(intSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;HashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntSortedSet()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedSet&lt;int&gt;(intSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntDictionary()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = intSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Dictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntSortedDictionary()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedDictionary&lt;int, bool&gt;(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntConcurrentDictionary()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new ConcurrentDictionary&lt;int, bool&gt;(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ConcurrentDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntImmutableList()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableList.CreateRange(intSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableList&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntImmutableHashSet()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableHashSet.CreateRange(intSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableHashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntArray()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = intSourceData.ToArray();&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Array&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.Diagnostics;&#10;using System.IO;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;&#10;namespace Benchmarks&#10;{&#10;    public class IntegerBenchmarks&#10;    {&#10;        // Benchmark iteration constants&#10;        public const int WarmupIterations = 5;&#10;        public const int ActualIterations = 50;&#10;&#10;        private int N { get; set; }&#10;        private int LookupCount { get; set; }&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private static readonly object _fileLock = new object();&#10;        private int _iterationCount = 0;&#10;&#10;        public void RunManual()&#10;        {&#10;            var nValues = new[] { 10, 100, 1000, 10000 };&#10;            var lookupValues = new[] { 10, 100, 1000, 10000 };&#10;&#10;            foreach (var n in nValues)&#10;            {&#10;                foreach (var lookupCount in lookupValues)&#10;                {&#10;                    N = n;&#10;                    LookupCount = lookupCount;&#10;                    &#10;                    Console.WriteLine($&quot;\nRunning for N={N}, LookupCount={LookupCount}&quot;);&#10;                    &#10;                    Setup();&#10;                    &#10;                    _iterationCount = 0;&#10;                    &#10;                    for (int i = 0; i &lt; WarmupIterations + ActualIterations; i++)&#10;                    {&#10;                        IterationSetup();&#10;                        &#10;                        IntList();&#10;                        IterationCleanup();&#10;                        &#10;                        IntHashSet();&#10;                        IterationCleanup();&#10;                        &#10;                        IntSortedSet();&#10;                        IterationCleanup();&#10;                        &#10;                        IntDictionary();&#10;                        IterationCleanup();&#10;                        &#10;                        IntSortedDictionary();&#10;                        IterationCleanup();&#10;                        &#10;                        IntConcurrentDictionary();&#10;                        IterationCleanup();&#10;                        &#10;                        IntImmutableList();&#10;                        IterationCleanup();&#10;                        &#10;                        IntImmutableHashSet();&#10;                        IterationCleanup();&#10;                        &#10;                        IntArray();&#10;                        IterationCleanup();&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;        }&#10;&#10;        public void IterationSetup()&#10;        {&#10;            _iterationCount++;&#10;        }&#10;&#10;        private void LogDetailedResults(string collectionType, int n, int lookupCount, TimeSpan creationTime, TimeSpan lookupTime, TimeSpan totalTime)&#10;        {&#10;            // Only log results after warmup iterations are complete&#10;            if (_iterationCount &lt;= WarmupIterations)&#10;            {&#10;                return; // Skip logging during warmup&#10;            }&#10;&#10;            // Use a hardcoded absolute path to ensure we can find it&#10;            var logPath = @&quot;C:\Users\Gustavo\Documents\Projetos\Estudos_Csharp\CSharpStudies\Topic6\Benchmarks\BenchmarkDotNet.Artifacts\detailed_results_integer.txt&quot;;&#10;            &#10;            // Ensure directory exists&#10;            Directory.CreateDirectory(Path.GetDirectoryName(logPath));&#10;            &#10;            lock (_fileLock)&#10;            {&#10;                try&#10;                {&#10;                    // Check if we need to write header BEFORE opening the file&#10;                    bool needsHeader = !File.Exists(logPath) || new FileInfo(logPath).Length == 0;&#10;                    &#10;                    using var writer = new StreamWriter(logPath, true);&#10;                    if (needsHeader)&#10;                    {&#10;                        // Write header if file doesn't exist or is empty&#10;                        writer.WriteLine(&quot;CollectionType,N,LookupCount,CreationTime_μs,LookupTime_μs,TotalTime_μs&quot;);&#10;                    }&#10;                    writer.WriteLine($&quot;{collectionType},{n},{lookupCount},{creationTime.TotalMicroseconds:F2},{lookupTime.TotalMicroseconds:F2},{totalTime.TotalMicroseconds:F2}&quot;);&#10;                    &#10;                    // Force write to disk&#10;                    writer.Flush();&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    // If there's an issue, write to a backup location we can debug&#10;                    var backupPath = @&quot;C:\temp\benchmark_debug_integer.txt&quot;;&#10;                    Directory.CreateDirectory(Path.GetDirectoryName(backupPath));&#10;                    File.AppendAllText(backupPath, $&quot;ERROR: {ex.Message}\n&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        public void IterationCleanup()&#10;        {&#10;            // Force garbage collection between iterations to prevent memory pressure interference&#10;            GC.Collect();&#10;            GC.WaitForPendingFinalizers();&#10;            GC.Collect();&#10;        }&#10;&#10;        public void IntList()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new List&lt;int&gt;(intSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;List&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntHashSet()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new HashSet&lt;int&gt;(intSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;HashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntSortedSet()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedSet&lt;int&gt;(intSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntDictionary()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = intSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Dictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntSortedDictionary()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedDictionary&lt;int, bool&gt;(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntConcurrentDictionary()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new ConcurrentDictionary&lt;int, bool&gt;(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ConcurrentDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntImmutableList()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableList.CreateRange(intSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableList&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntImmutableHashSet()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableHashSet.CreateRange(intSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableHashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;&#10;        public void IntArray()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = intSourceData.ToArray();&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in intLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Array&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/IntegerCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/IntegerCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class IntegerCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntDictionary_CreationAndLookup()&#10;        {&#10;            var collection = intSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntSortedDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new SortedDictionary&lt;int, bool&gt;(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ParallelBenchmarkRunner.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ParallelBenchmarkRunner.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Diagnostics;&#10;using System.Threading.Tasks;&#10;using BenchmarkDotNet.Running;&#10;using BenchmarkDotNet.Configs;&#10;using BenchmarkDotNet.Jobs;&#10;using BenchmarkDotNet.Toolchains.CsProj;&#10;using BenchmarkDotNet.Toolchains.DotNetCli;&#10;&#10;namespace Benchmarks&#10;{&#10;    public class ParallelBenchmarkRunner&#10;    {&#10;        private readonly int _parallelInstances;&#10;        private readonly ManualConfig _releaseConfig;&#10;&#10;        public ParallelBenchmarkRunner(int parallelInstances = 8)&#10;        {&#10;            _parallelInstances = parallelInstances;&#10;            &#10;            // Create optimized release configuration&#10;            _releaseConfig = ManualConfig.Create(DefaultConfig.Instance)&#10;                .WithOptions(ConfigOptions.DisableOptimizationsValidator)&#10;                .AddJob(Job.Default&#10;                    .WithToolchain(CsProjCoreToolchain.NetCoreApp90)&#10;                    .WithId(&quot;ReleaseJob&quot;))&#10;                .WithOption(ConfigOptions.JoinSummary, true);&#10;        }&#10;&#10;        public async Task RunBenchmarksInParallel()&#10;        {&#10;            Console.WriteLine($&quot;Starting parallel benchmark execution with {_parallelInstances} instances...&quot;);&#10;            Console.WriteLine($&quot;CPU Core Count: {Environment.ProcessorCount}&quot;);&#10;            Console.WriteLine(new string('=', 80));&#10;&#10;            var benchmarkTasks = new List&lt;Task&gt;();&#10;            var results = new ConcurrentBag&lt;BenchmarkResult&gt;();&#10;            var stopwatch = Stopwatch.StartNew();&#10;&#10;            // Define different benchmark scenarios to run in parallel&#10;            var benchmarkScenarios = new List&lt;BenchmarkScenario&gt;&#10;            {&#10;                new(&quot;IntegerCollections&quot;, () =&gt; RunBenchmarkSafely&lt;IntegerCollectionBenchmarks&gt;()),&#10;                new(&quot;StringCollections&quot;, () =&gt; RunBenchmarkSafely&lt;StringCollectionBenchmarks&gt;()),&#10;                new(&quot;GuidCollections&quot;, () =&gt; RunBenchmarkSafely&lt;GuidCollectionBenchmarks&gt;()),&#10;                new(&quot;CustomValueTypes&quot;, () =&gt; RunBenchmarkSafely&lt;CustomValueTypeBenchmarks&gt;()),&#10;                new(&quot;CustomReferenceTypes&quot;, () =&gt; RunBenchmarkSafely&lt;CustomReferenceTypeBenchmarks&gt;()),&#10;                new(&quot;ImmutableCollections&quot;, () =&gt; RunBenchmarkSafely&lt;ImmutableCollectionBenchmarks&gt;()),&#10;                new(&quot;ConcurrentCollections&quot;, () =&gt; RunBenchmarkSafely&lt;ConcurrentCollectionBenchmarks&gt;()),&#10;                new(&quot;ArrayOperations&quot;, () =&gt; RunBenchmarkSafely&lt;ArrayOperationBenchmarks&gt;())&#10;            };&#10;&#10;            // Take only the number of scenarios we want to run in parallel&#10;            var scenariosToRun = benchmarkScenarios.Take(_parallelInstances);&#10;&#10;            foreach (var scenario in scenariosToRun)&#10;            {&#10;                var task = Task.Run(async () =&gt;&#10;                {&#10;                    var taskStopwatch = Stopwatch.StartNew();&#10;                    Console.WriteLine($&quot;[{DateTime.Now:HH:mm:ss}] Starting {scenario.Name}...&quot;);&#10;                    &#10;                    try&#10;                    {&#10;                        var result = await scenario.ExecuteAsync();&#10;                        taskStopwatch.Stop();&#10;                        &#10;                        var benchmarkResult = new BenchmarkResult&#10;                        {&#10;                            ScenarioName = scenario.Name,&#10;                            Success = result != null,&#10;                            Duration = taskStopwatch.Elapsed,&#10;                            ErrorMessage = result == null ? &quot;Benchmark returned null&quot; : null&#10;                        };&#10;                        &#10;                        results.Add(benchmarkResult);&#10;                        Console.WriteLine($&quot;[{DateTime.Now:HH:mm:ss}] Completed {scenario.Name} in {taskStopwatch.Elapsed:mm\\:ss}&quot;);&#10;                    }&#10;                    catch (Exception ex)&#10;                    {&#10;                        taskStopwatch.Stop();&#10;                        var benchmarkResult = new BenchmarkResult&#10;                        {&#10;                            ScenarioName = scenario.Name,&#10;                            Success = false,&#10;                            Duration = taskStopwatch.Elapsed,&#10;                            ErrorMessage = ex.Message&#10;                        };&#10;                        &#10;                        results.Add(benchmarkResult);&#10;                        Console.WriteLine($&quot;[{DateTime.Now:HH:mm:ss}] Failed {scenario.Name}: {ex.Message}&quot;);&#10;                    }&#10;                });&#10;                &#10;                benchmarkTasks.Add(task);&#10;            }&#10;&#10;            // Wait for all benchmarks to complete&#10;            await Task.WhenAll(benchmarkTasks);&#10;            stopwatch.Stop();&#10;&#10;            // Print summary&#10;            Console.WriteLine(&quot;\n&quot; + new string('=', 80));&#10;            Console.WriteLine(&quot;PARALLEL BENCHMARK EXECUTION SUMMARY&quot;);&#10;            Console.WriteLine(new string('=', 80));&#10;            Console.WriteLine($&quot;Total Execution Time: {stopwatch.Elapsed:mm\\:ss}&quot;);&#10;            Console.WriteLine($&quot;Parallel Instances: {_parallelInstances}&quot;);&#10;            Console.WriteLine();&#10;&#10;            foreach (var result in results)&#10;            {&#10;                var status = result.Success ? &quot;✓ SUCCESS&quot; : &quot;✗ FAILED&quot;;&#10;                Console.WriteLine($&quot;{status,-12} {result.ScenarioName,-25} Duration: {result.Duration:mm\\:ss}&quot;);&#10;                if (!result.Success &amp;&amp; !string.IsNullOrEmpty(result.ErrorMessage))&#10;                {&#10;                    Console.WriteLine($&quot;             Error: {result.ErrorMessage}&quot;);&#10;                }&#10;            }&#10;&#10;            var successCount = results.Count(r =&gt; r.Success);&#10;            var failCount = results.Count(r =&gt; !r.Success);&#10;            &#10;            Console.WriteLine();&#10;            Console.WriteLine($&quot;Results: {successCount} successful, {failCount} failed&quot;);&#10;            Console.WriteLine(new string('=', 80));&#10;        }&#10;&#10;        private async Task&lt;object&gt; RunBenchmarkSafely&lt;T&gt;() where T : class&#10;        {&#10;            return await Task.Run(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    return BenchmarkRunner.Run&lt;T&gt;(_releaseConfig);&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    Console.WriteLine($&quot;Error running benchmark {typeof(T).Name}: {ex.Message}&quot;);&#10;                    throw;&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    public record BenchmarkScenario(string Name, Func&lt;Task&lt;object&gt;&gt; ExecuteAsync);&#10;&#10;    public class BenchmarkResult&#10;    {&#10;        public string ScenarioName { get; set; } = string.Empty;&#10;        public bool Success { get; set; }&#10;        public TimeSpan Duration { get; set; }&#10;        public string? ErrorMessage { get; set; }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ParallelizedGuidBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ParallelizedGuidBenchmarks.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.Diagnostics;&#10;using System.IO;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using BenchmarkDotNet.Attributes;&#10;using BenchmarkDotNet.Jobs;&#10;using BenchmarkDotNet.Engines;&#10;&#10;namespace Benchmarks&#10;{&#10;    [SimpleJob(RunStrategy.Monitoring, warmupCount: 5, iterationCount: 50)]&#10;    [MemoryDiagnoser]&#10;    [HardwareCounters(HardwareCounter.BranchMispredictions, HardwareCounter.CacheMisses)]&#10;    public class ParallelizedGuidBenchmarks&#10;    {&#10;        [Params(10, 100, 1000, 10000)]&#10;        public int N { get; set; }&#10;&#10;        [Params(10, 100, 1000, 10000)]&#10;        public int LookupCount { get; set; }&#10;&#10;        private Guid[] guidSourceData = null!;&#10;        private Guid[] guidLookupItems = null!;&#10;        private static readonly object _fileLock = new object();&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            // Generate N unique GUIDs for the collection&#10;            guidSourceData = new Guid[N];&#10;            for (int i = 0; i &lt; N; i++)&#10;            {&#10;                guidSourceData[i] = Guid.NewGuid();&#10;            }&#10;&#10;            // Generate lookup items (mix of existing and non-existing GUIDs)&#10;            guidLookupItems = new Guid[LookupCount];&#10;            var random = new Random(42); // Fixed seed for reproducibility&#10;&#10;            for (int i = 0; i &lt; LookupCount; i++)&#10;            {&#10;                if (i &lt; N &amp;&amp; random.NextDouble() &lt; 0.7) // 70% chance to use existing GUID&#10;                {&#10;                    guidLookupItems[i] = guidSourceData[random.Next(N)];&#10;                }&#10;                else // 30% chance to use non-existing GUID&#10;                {&#10;                    guidLookupItems[i] = Guid.NewGuid();&#10;                }&#10;            }&#10;        }&#10;&#10;        [IterationCleanup]&#10;        public void IterationCleanup()&#10;        {&#10;            // Force garbage collection between iterations to prevent memory pressure interference&#10;            GC.Collect();&#10;            GC.WaitForPendingFinalizers();&#10;            GC.Collect();&#10;        }&#10;&#10;        private void LogDetailedResults(string collectionType, int n, int lookupCount, TimeSpan creationTime, TimeSpan lookupTime, TimeSpan totalTime)&#10;        {&#10;            // Use a hardcoded absolute path to ensure we can find it&#10;            var logPath = @&quot;C:\Users\Gustavo\Documents\Projetos\Estudos_Csharp\CSharpStudies\Topic6\Benchmarks\BenchmarkDotNet.Artifacts\detailed_results_guid.txt&quot;;&#10;            &#10;            // Ensure directory exists&#10;            Directory.CreateDirectory(Path.GetDirectoryName(logPath));&#10;            &#10;            lock (_fileLock)&#10;            {&#10;                try&#10;                {&#10;                    // Check if we need to write header BEFORE opening the file&#10;                    bool needsHeader = !File.Exists(logPath) || new FileInfo(logPath).Length == 0;&#10;                    &#10;                    using var writer = new StreamWriter(logPath, true);&#10;                    if (needsHeader)&#10;                    {&#10;                        // Write header if file doesn't exist or is empty&#10;                        writer.WriteLine(&quot;CollectionType,N,LookupCount,CreationTime_μs,LookupTime_μs,TotalTime_μs&quot;);&#10;                    }&#10;                    writer.WriteLine($&quot;{collectionType},{n},{lookupCount},{creationTime.TotalMicroseconds:F2},{lookupTime.TotalMicroseconds:F2},{totalTime.TotalMicroseconds:F2}&quot;);&#10;                    &#10;                    // Force write to disk&#10;                    writer.Flush();&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    // If there's an issue, write to a backup location we can debug&#10;                    var backupPath = @&quot;C:\temp\benchmark_debug_guid.txt&quot;;&#10;                    Directory.CreateDirectory(Path.GetDirectoryName(backupPath));&#10;                    File.AppendAllText(backupPath, $&quot;ERROR: {ex.Message}\n&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidArray_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = guidSourceData.ToArray();&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Array&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidList_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new List&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;List&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidHashSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new HashSet&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;HashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidSortedSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedSet&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = guidSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Dictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidSortedDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidConcurrentDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new ConcurrentDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ConcurrentDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidImmutableList_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableList.CreateRange(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableList&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidImmutableHashSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableHashSet.CreateRange(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableHashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.Diagnostics;&#10;using System.IO;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using BenchmarkDotNet.Attributes;&#10;using BenchmarkDotNet.Jobs;&#10;using BenchmarkDotNet.Engines;&#10;&#10;namespace Benchmarks&#10;{&#10;    [SimpleJob(RunStrategy.Monitoring, warmupCount: 5, iterationCount: 50)]&#10;    [MemoryDiagnoser]&#10;    public class ParallelizedGuidBenchmarks&#10;    {&#10;        [Params(10, 100, 1000, 10000)]&#10;        public int N { get; set; }&#10;&#10;        [Params(10, 100, 1000, 10000)]&#10;        public int LookupCount { get; set; }&#10;&#10;        private Guid[] guidSourceData = null!;&#10;        private Guid[] guidLookupItems = null!;&#10;        private static readonly object _fileLock = new object();&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            // Generate N unique GUIDs for the collection&#10;            guidSourceData = new Guid[N];&#10;            for (int i = 0; i &lt; N; i++)&#10;            {&#10;                guidSourceData[i] = Guid.NewGuid();&#10;            }&#10;&#10;            // Generate lookup items (mix of existing and non-existing GUIDs)&#10;            guidLookupItems = new Guid[LookupCount];&#10;            var random = new Random(42); // Fixed seed for reproducibility&#10;&#10;            for (int i = 0; i &lt; LookupCount; i++)&#10;            {&#10;                if (i &lt; N &amp;&amp; random.NextDouble() &lt; 0.7) // 70% chance to use existing GUID&#10;                {&#10;                    guidLookupItems[i] = guidSourceData[random.Next(N)];&#10;                }&#10;                else // 30% chance to use non-existing GUID&#10;                {&#10;                    guidLookupItems[i] = Guid.NewGuid();&#10;                }&#10;            }&#10;        }&#10;&#10;        [IterationCleanup]&#10;        public void IterationCleanup()&#10;        {&#10;            // Force garbage collection between iterations to prevent memory pressure interference&#10;            GC.Collect();&#10;            GC.WaitForPendingFinalizers();&#10;            GC.Collect();&#10;        }&#10;&#10;        private void LogDetailedResults(string collectionType, int n, int lookupCount, TimeSpan creationTime, TimeSpan lookupTime, TimeSpan totalTime)&#10;        {&#10;            // Use a hardcoded absolute path to ensure we can find it&#10;            var logPath = @&quot;C:\Users\Gustavo\Documents\Projetos\Estudos_Csharp\CSharpStudies\Topic6\Benchmarks\BenchmarkDotNet.Artifacts\detailed_results_guid.txt&quot;;&#10;            &#10;            // Ensure directory exists&#10;            Directory.CreateDirectory(Path.GetDirectoryName(logPath));&#10;            &#10;            lock (_fileLock)&#10;            {&#10;                try&#10;                {&#10;                    // Check if we need to write header BEFORE opening the file&#10;                    bool needsHeader = !File.Exists(logPath) || new FileInfo(logPath).Length == 0;&#10;                    &#10;                    using var writer = new StreamWriter(logPath, true);&#10;                    if (needsHeader)&#10;                    {&#10;                        // Write header if file doesn't exist or is empty&#10;                        writer.WriteLine(&quot;CollectionType,N,LookupCount,CreationTime_μs,LookupTime_μs,TotalTime_μs&quot;);&#10;                    }&#10;                    writer.WriteLine($&quot;{collectionType},{n},{lookupCount},{creationTime.TotalMicroseconds:F2},{lookupTime.TotalMicroseconds:F2},{totalTime.TotalMicroseconds:F2}&quot;);&#10;                    &#10;                    // Force write to disk&#10;                    writer.Flush();&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    // If there's an issue, write to a backup location we can debug&#10;                    var backupPath = @&quot;C:\temp\benchmark_debug_guid.txt&quot;;&#10;                    Directory.CreateDirectory(Path.GetDirectoryName(backupPath));&#10;                    File.AppendAllText(backupPath, $&quot;ERROR: {ex.Message}\n&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidArray_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = guidSourceData.ToArray();&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Array&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidList_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new List&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;List&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidHashSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new HashSet&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;HashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidSortedSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedSet&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = guidSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Dictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidSortedDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidConcurrentDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new ConcurrentDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ConcurrentDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidImmutableList_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableList.CreateRange(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableList&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidImmutableHashSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableHashSet.CreateRange(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableHashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/Program.cs" />
              <option name="originalContent" value="using System;&#10;using System.IO;&#10;using System.Linq;&#10;using BenchmarkDotNet.Running;&#10;&#10;namespace Benchmarks&#10;{&#10;    public class Program&#10;    {&#10;        public static void Main(string[] args)&#10;        {&#10;            if (args.Length == 0)&#10;            {&#10;                ShowHelp();&#10;                return;&#10;            }&#10;&#10;            var command = args[0].ToLower();&#10;&#10;            switch (command)&#10;            {&#10;                case &quot;benchmark&quot;:&#10;                case &quot;bench&quot;:&#10;                case &quot;b&quot;:&#10;                    var dataType = args.Length &gt; 1 ? args[1].ToLower() : &quot;&quot;;&#10;                    RunBenchmarks(dataType);&#10;                    break;&#10;                    &#10;                case &quot;analyze&quot;:&#10;                case &quot;analysis&quot;:&#10;                case &quot;a&quot;:&#10;                case &quot;summary&quot;:&#10;                case &quot;sum&quot;:&#10;                case &quot;s&quot;:&#10;                    var analyzeDataType = args.Length &gt; 1 ? args[1].ToLower() : &quot;int&quot;;&#10;                    RunStatisticalAnalysis(analyzeDataType);&#10;                    break;&#10;                    &#10;                case &quot;help&quot;:&#10;                case &quot;h&quot;:&#10;                case &quot;?&quot;:&#10;                    ShowHelp();&#10;                    break;&#10;                    &#10;                default:&#10;                    Console.WriteLine($&quot;Unknown command: {command}&quot;);&#10;                    ShowHelp();&#10;                    break;&#10;            }&#10;        }&#10;&#10;        private static void ShowHelp()&#10;        {&#10;            Console.WriteLine(&quot;=== C# Collection Performance Benchmarks ===&quot;);&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;Usage: dotnet run -c Release &lt;command&gt; [datatype]&quot;);&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;Commands:&quot;);&#10;            Console.WriteLine(&quot;  benchmark, bench, b    - Run performance benchmarks (30 iterations each)&quot;);&#10;            Console.WriteLine(&quot;  analyze, analysis, a   - Analyze existing results with statistics&quot;);&#10;            Console.WriteLine(&quot;  summary, sum, s        - Same as analyze (alias)&quot;);&#10;            Console.WriteLine(&quot;  help, h, ?            - Show this help message&quot;);&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;Data Types:&quot;);&#10;            Console.WriteLine(&quot;  int, integer          - Integer benchmarks&quot;);&#10;            Console.WriteLine(&quot;  string, str           - String benchmarks&quot;);&#10;            Console.WriteLine(&quot;  guid                  - GUID benchmarks&quot;);&#10;            Console.WriteLine(&quot;  all                   - All data types&quot;);&#10;            Console.WriteLine();&#10;            Console.WriteLine(&quot;Examples:&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark int       # Run integer benchmarks&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark string     # Run string benchmarks&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark guid       # Run GUID benchmarks&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark all        # Run all benchmarks&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release analyze int          # Analyze integer results&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release analyze string       # Analyze string results&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release analyze guid         # Analyze GUID results&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release summary guid         # Same as analyze guid&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release b guid               # Short form benchmark&quot;);&#10;            Console.WriteLine(&quot;  dotnet run -c Release s guid               # Short form summary/analyze&quot;);&#10;        }&#10;&#10;        private static void RunBenchmarks(string dataType)&#10;        {&#10;            Console.WriteLine(&quot;=== Running Performance Benchmarks ===&quot;);&#10;            Console.WriteLine(&quot;This will run collection benchmarks with detailed timing measurements.&quot;);&#10;            Console.WriteLine(&quot;This may take several minutes to complete...&quot;);&#10;            Console.WriteLine();&#10;&#10;            switch (dataType)&#10;            {&#10;                case &quot;int&quot;:&#10;                case &quot;integer&quot;:&#10;                case &quot;&quot;:&#10;                    Console.WriteLine(&quot;Running INTEGER benchmarks...&quot;);&#10;                    BenchmarkRunner.Run&lt;IntegerBenchmarks&gt;();&#10;                    break;&#10;                    &#10;                case &quot;string&quot;:&#10;                case &quot;str&quot;:&#10;                    Console.WriteLine(&quot;Running STRING benchmarks...&quot;);&#10;                    BenchmarkRunner.Run&lt;StringBenchmarks&gt;();&#10;                    break;&#10;&#10;                case &quot;guid&quot;:&#10;                    Console.WriteLine(&quot;Running GUID benchmarks...&quot;);&#10;                    BenchmarkRunner.Run&lt;GuidBenchmarks&gt;();&#10;                    break;&#10;                    &#10;                case &quot;all&quot;:&#10;                    Console.WriteLine(&quot;Running ALL benchmark types...&quot;);&#10;                    Console.WriteLine(&quot;\n1/3 Running INTEGER benchmarks...&quot;);&#10;                    BenchmarkRunner.Run&lt;IntegerBenchmarks&gt;();&#10;                    Console.WriteLine(&quot;\n2/3 Running STRING benchmarks...&quot;);&#10;                    BenchmarkRunner.Run&lt;StringBenchmarks&gt;();&#10;                    Console.WriteLine(&quot;\n3/3 Running GUID benchmarks...&quot;);&#10;                    BenchmarkRunner.Run&lt;GuidBenchmarks&gt;();&#10;                    break;&#10;                    &#10;                default:&#10;                    Console.WriteLine($&quot;Unknown data type: {dataType}&quot;);&#10;                    Console.WriteLine(&quot;Available types: int, string, guid, all&quot;);&#10;                    ShowHelp();&#10;                    break;&#10;            }&#10;        }&#10;&#10;        private static void RunStatisticalAnalysis(string dataType)&#10;        {&#10;            Console.WriteLine(&quot;=== Benchmark Result Statistical Analysis ===&quot;);&#10;            &#10;            var analyzer = new BenchmarkResultAnalyzer();&#10;            &#10;            // Determine file paths based on data type&#10;            string resultsFileName, summaryFileName, reportFileName;&#10;            switch (dataType)&#10;            {&#10;                case &quot;string&quot;:&#10;                case &quot;str&quot;:&#10;                    resultsFileName = &quot;detailed_results_string.txt&quot;;&#10;                    summaryFileName = &quot;statistical_summary_string.csv&quot;;&#10;                    reportFileName = &quot;performance_report_string.md&quot;;&#10;                    Console.WriteLine(&quot;Analyzing STRING benchmark results...&quot;);&#10;                    break;&#10;&#10;                case &quot;guid&quot;:&#10;                    resultsFileName = &quot;detailed_results_guid.txt&quot;;&#10;                    summaryFileName = &quot;statistical_summary_guid.csv&quot;;&#10;                    reportFileName = &quot;performance_report_guid.md&quot;;&#10;                    Console.WriteLine(&quot;Analyzing GUID benchmark results...&quot;);&#10;                    break;&#10;                    &#10;                case &quot;int&quot;:&#10;                case &quot;integer&quot;:&#10;                default:&#10;                    resultsFileName = &quot;detailed_results_integer.txt&quot;;&#10;                    summaryFileName = &quot;statistical_summary_integer.csv&quot;;&#10;                    reportFileName = &quot;performance_report_integer.md&quot;;&#10;                    Console.WriteLine(&quot;Analyzing INTEGER benchmark results...&quot;);&#10;                    break;&#10;            }&#10;            &#10;            var resultsPath = Path.Combine(Environment.CurrentDirectory, &quot;BenchmarkDotNet.Artifacts&quot;, resultsFileName);&#10;            var summaryPath = Path.Combine(Environment.CurrentDirectory, &quot;BenchmarkDotNet.Artifacts&quot;, summaryFileName);&#10;            var reportPath = Path.Combine(Environment.CurrentDirectory, &quot;BenchmarkDotNet.Artifacts&quot;, reportFileName);&#10;            &#10;            Console.WriteLine($&quot;Reading results from: {resultsPath}&quot;);&#10;            &#10;            // Read the benchmark results&#10;            var results = analyzer.ReadResults(resultsPath);&#10;            &#10;            if (results.Count == 0)&#10;            {&#10;                Console.WriteLine($&quot;No {dataType} results found. Make sure the {resultsFileName} file exists and contains data.&quot;);&#10;                Console.WriteLine($&quot;Run 'dotnet run -c Release benchmark {dataType}' first to generate benchmark data.&quot;);&#10;                return;&#10;            }&#10;            &#10;            Console.WriteLine($&quot;Loaded {results.Count} benchmark results&quot;);&#10;            &#10;            // Analyze with outlier removal (Z-score threshold of 2.0)&#10;            Console.WriteLine(&quot;Performing statistical analysis with outlier detection...&quot;);&#10;            var summaries = analyzer.AnalyzeResults(results, outlierThreshold: 2.0);&#10;            &#10;            Console.WriteLine($&quot;Generated {summaries.Count} statistical summaries&quot;);&#10;            &#10;            // Write statistical summary to CSV&#10;            analyzer.WriteSummaryToFile(summaries, summaryPath);&#10;            &#10;            // Generate performance report&#10;            analyzer.GeneratePerformanceReport(summaries, reportPath);&#10;            &#10;            // Display some quick stats&#10;            Console.WriteLine(&quot;\n=== Quick Overview ===&quot;);&#10;            var totalOutliers = summaries.Sum(s =&gt; s.OutliersRemoved);&#10;            var totalSamples = summaries.Sum(s =&gt; s.SampleCount);&#10;            Console.WriteLine($&quot;Total samples analyzed: {totalSamples}&quot;);&#10;            Console.WriteLine($&quot;Total outliers removed: {totalOutliers} ({(double)totalOutliers/totalSamples*100:F1}%)&quot;);&#10;            &#10;            // Show top performers for largest scenario&#10;            var largestScenario = summaries.Where(s =&gt; s.N == 10000 &amp;&amp; s.LookupCount == 10000).OrderBy(s =&gt; s.TotalMean).Take(3).ToList();&#10;            if (largestScenario.Any())&#10;            {&#10;                Console.WriteLine(&quot;\nTop 3 performers for N=10,000, Lookups=10,000:&quot;);&#10;                for (int i = 0; i &lt; largestScenario.Count; i++)&#10;                {&#10;                    var s = largestScenario[i];&#10;                    Console.WriteLine($&quot;{i+1}. {s.CollectionType}: {s.TotalMean:F1} μs (±{s.TotalStdDev:F1})&quot;);&#10;                }&#10;            }&#10;            &#10;            Console.WriteLine($&quot;\nFiles generated:&quot;);&#10;            Console.WriteLine($&quot;- Statistical Summary: {summaryPath}&quot;);&#10;            Console.WriteLine($&quot;- Performance Report: {reportPath}&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#13;&#10;using System.IO;&#13;&#10;using System.Linq;&#13;&#10;using BenchmarkDotNet.Running;&#13;&#10;&#13;&#10;namespace Benchmarks&#13;&#10;{&#13;&#10;    public class Program&#13;&#10;    {&#13;&#10;        public static void Main(string[] args)&#13;&#10;        {&#13;&#10;            if (args.Length == 0)&#13;&#10;            {&#13;&#10;                ShowHelp();&#13;&#10;                return;&#13;&#10;            }&#13;&#10;&#13;&#10;            var command = args[0].ToLower();&#13;&#10;&#13;&#10;            switch (command)&#13;&#10;            {&#13;&#10;                case &quot;benchmark&quot;:&#13;&#10;                case &quot;bench&quot;:&#13;&#10;                case &quot;b&quot;:&#13;&#10;                    var dataType = args.Length &gt; 1 ? args[1].ToLower() : &quot;&quot;;&#13;&#10;                    RunBenchmarks(dataType);&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                case &quot;analyze&quot;:&#13;&#10;                case &quot;analysis&quot;:&#13;&#10;                case &quot;a&quot;:&#13;&#10;                case &quot;summary&quot;:&#13;&#10;                case &quot;sum&quot;:&#13;&#10;                case &quot;s&quot;:&#13;&#10;                    var analyzeDataType = args.Length &gt; 1 ? args[1].ToLower() : &quot;int&quot;;&#13;&#10;                    RunStatisticalAnalysis(analyzeDataType);&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                case &quot;help&quot;:&#13;&#10;                case &quot;h&quot;:&#13;&#10;                case &quot;?&quot;:&#13;&#10;                    ShowHelp();&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                default:&#13;&#10;                    Console.WriteLine($&quot;Unknown command: {command}&quot;);&#13;&#10;                    ShowHelp();&#13;&#10;                    break;&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        private static void ShowHelp()&#13;&#10;        {&#13;&#10;            Console.WriteLine(&quot;=== C# Collection Performance Benchmarks ===&quot;);&#13;&#10;            Console.WriteLine();&#13;&#10;            Console.WriteLine(&quot;Usage: dotnet run -c Release &lt;command&gt; [datatype]&quot;);&#13;&#10;            Console.WriteLine();&#13;&#10;            Console.WriteLine(&quot;Commands:&quot;);&#13;&#10;            Console.WriteLine(&quot;  benchmark, bench, b    - Run performance benchmarks (30 iterations each)&quot;);&#13;&#10;            Console.WriteLine(&quot;  analyze, analysis, a   - Analyze existing results with statistics&quot;);&#13;&#10;            Console.WriteLine(&quot;  summary, sum, s        - Same as analyze (alias)&quot;);&#13;&#10;            Console.WriteLine(&quot;  help, h, ?            - Show this help message&quot;);&#13;&#10;            Console.WriteLine();&#13;&#10;            Console.WriteLine(&quot;Data Types:&quot;);&#13;&#10;            Console.WriteLine(&quot;  int, integer          - Integer benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  string, str           - String benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  guid                  - GUID benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  all                   - All data types&quot;);&#13;&#10;            Console.WriteLine();&#13;&#10;            Console.WriteLine(&quot;Examples:&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark int       # Run integer benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark string     # Run string benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark guid       # Run GUID benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release benchmark all        # Run all benchmarks&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release analyze int          # Analyze integer results&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release analyze string       # Analyze string results&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release analyze guid         # Analyze GUID results&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release summary guid         # Same as analyze guid&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release b guid               # Short form benchmark&quot;);&#13;&#10;            Console.WriteLine(&quot;  dotnet run -c Release s guid               # Short form summary/analyze&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        private static void RunBenchmarks(string dataType)&#13;&#10;        {&#13;&#10;            Console.WriteLine(&quot;=== Running Performance Benchmarks ===&quot;);&#13;&#10;            Console.WriteLine(&quot;This will run collection benchmarks with detailed timing measurements.&quot;);&#13;&#10;            Console.WriteLine(&quot;This may take several minutes to complete...&quot;);&#13;&#10;            Console.WriteLine();&#13;&#10;&#13;&#10;            switch (dataType)&#13;&#10;            {&#13;&#10;                case &quot;int&quot;:&#13;&#10;                case &quot;integer&quot;:&#13;&#10;                case &quot;&quot;:&#13;&#10;                    Console.WriteLine(&quot;Running INTEGER benchmarks...&quot;);&#13;&#10;                    var intBenchmarks = new IntegerBenchmarks();&#13;&#10;                    intBenchmarks.RunManual();&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                case &quot;string&quot;:&#13;&#10;                case &quot;str&quot;:&#13;&#10;                    Console.WriteLine(&quot;Running STRING benchmarks...&quot;);&#13;&#10;                    BenchmarkRunner.Run&lt;StringBenchmarks&gt;();&#13;&#10;                    break;&#13;&#10;&#13;&#10;                case &quot;guid&quot;:&#13;&#10;                    Console.WriteLine(&quot;Running GUID benchmarks...&quot;);&#13;&#10;                    BenchmarkRunner.Run&lt;GuidBenchmarks&gt;();&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                case &quot;all&quot;:&#13;&#10;                    Console.WriteLine(&quot;Running ALL benchmark types...&quot;);&#13;&#10;                    Console.WriteLine(&quot;\n1/3 Running INTEGER benchmarks...&quot;);&#13;&#10;                    var allIntBenchmarks = new IntegerBenchmarks();&#13;&#10;                    allIntBenchmarks.RunManual();&#13;&#10;                    Console.WriteLine(&quot;\n2/3 Running STRING benchmarks...&quot;);&#13;&#10;                    BenchmarkRunner.Run&lt;StringBenchmarks&gt;();&#13;&#10;                    Console.WriteLine(&quot;\n3/3 Running GUID benchmarks...&quot;);&#13;&#10;                    BenchmarkRunner.Run&lt;GuidBenchmarks&gt;();&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                default:&#13;&#10;                    Console.WriteLine($&quot;Unknown data type: {dataType}&quot;);&#13;&#10;                    Console.WriteLine(&quot;Available types: int, string, guid, all&quot;);&#13;&#10;                    ShowHelp();&#13;&#10;                    break;&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        private static void RunStatisticalAnalysis(string dataType)&#13;&#10;        {&#13;&#10;            Console.WriteLine(&quot;=== Benchmark Result Statistical Analysis ===&quot;);&#13;&#10;            &#13;&#10;            var analyzer = new BenchmarkResultAnalyzer();&#13;&#10;            &#13;&#10;            // Determine file paths based on data type&#13;&#10;            string resultsFileName, summaryFileName, reportFileName;&#13;&#10;            switch (dataType)&#13;&#10;            {&#13;&#10;                case &quot;string&quot;:&#13;&#10;                case &quot;str&quot;:&#13;&#10;                    resultsFileName = &quot;detailed_results_string.txt&quot;;&#13;&#10;                    summaryFileName = &quot;statistical_summary_string.csv&quot;;&#13;&#10;                    reportFileName = &quot;performance_report_string.md&quot;;&#13;&#10;                    Console.WriteLine(&quot;Analyzing STRING benchmark results...&quot;);&#13;&#10;                    break;&#13;&#10;&#13;&#10;                case &quot;guid&quot;:&#13;&#10;                    resultsFileName = &quot;detailed_results_guid.txt&quot;;&#13;&#10;                    summaryFileName = &quot;statistical_summary_guid.csv&quot;;&#13;&#10;                    reportFileName = &quot;performance_report_guid.md&quot;;&#13;&#10;                    Console.WriteLine(&quot;Analyzing GUID benchmark results...&quot;);&#13;&#10;                    break;&#13;&#10;                    &#13;&#10;                case &quot;int&quot;:&#13;&#10;                case &quot;integer&quot;:&#13;&#10;                default:&#13;&#10;                    resultsFileName = &quot;detailed_results_integer.txt&quot;;&#13;&#10;                    summaryFileName = &quot;statistical_summary_integer.csv&quot;;&#13;&#10;                    reportFileName = &quot;performance_report_integer.md&quot;;&#13;&#10;                    Console.WriteLine(&quot;Analyzing INTEGER benchmark results...&quot;);&#13;&#10;                    break;&#13;&#10;            }&#13;&#10;            &#13;&#10;            var resultsPath = Path.Combine(Environment.CurrentDirectory, &quot;BenchmarkDotNet.Artifacts&quot;, resultsFileName);&#13;&#10;            var summaryPath = Path.Combine(Environment.CurrentDirectory, &quot;BenchmarkDotNet.Artifacts&quot;, summaryFileName);&#13;&#10;            var reportPath = Path.Combine(Environment.CurrentDirectory, &quot;BenchmarkDotNet.Artifacts&quot;, reportFileName);&#13;&#10;            &#13;&#10;            Console.WriteLine($&quot;Reading results from: {resultsPath}&quot;);&#13;&#10;            &#13;&#10;            // Read the benchmark results&#13;&#10;            var results = analyzer.ReadResults(resultsPath);&#13;&#10;            &#13;&#10;            if (results.Count == 0)&#13;&#10;            {&#13;&#10;                Console.WriteLine($&quot;No {dataType} results found. Make sure the {resultsFileName} file exists and contains data.&quot;);&#13;&#10;                Console.WriteLine($&quot;Run 'dotnet run -c Release benchmark {dataType}' first to generate benchmark data.&quot;);&#13;&#10;                return;&#13;&#10;            }&#13;&#10;            &#13;&#10;            Console.WriteLine($&quot;Loaded {results.Count} benchmark results&quot;);&#13;&#10;            &#13;&#10;            // Analyze with outlier removal (Z-score threshold of 2.0)&#13;&#10;            Console.WriteLine(&quot;Performing statistical analysis with outlier detection...&quot;);&#13;&#10;            var summaries = analyzer.AnalyzeResults(results, outlierThreshold: 2.0);&#13;&#10;            &#13;&#10;            Console.WriteLine($&quot;Generated {summaries.Count} statistical summaries&quot;);&#13;&#10;            &#13;&#10;            // Write statistical summary to CSV&#13;&#10;            analyzer.WriteSummaryToFile(summaries, summaryPath);&#13;&#10;            &#13;&#10;            // Generate performance report&#13;&#10;            analyzer.GeneratePerformanceReport(summaries, reportPath);&#13;&#10;            &#13;&#10;            // Display some quick stats&#13;&#10;            Console.WriteLine(&quot;\n=== Quick Overview ===&quot;);&#13;&#10;            var totalOutliers = summaries.Sum(s =&gt; s.OutliersRemoved);&#13;&#10;            var totalSamples = summaries.Sum(s =&gt; s.SampleCount);&#13;&#10;            Console.WriteLine($&quot;Total samples analyzed: {totalSamples}&quot;);&#13;&#10;            Console.WriteLine($&quot;Total outliers removed: {totalOutliers} ({(double)totalOutliers/totalSamples*100:F1}%)&quot;);&#13;&#10;            &#13;&#10;            // Show top performers for largest scenario&#13;&#10;            var largestScenario = summaries.Where(s =&gt; s.N == 10000 &amp;&amp; s.LookupCount == 10000).OrderBy(s =&gt; s.TotalMean).Take(3).ToList();&#13;&#10;            if (largestScenario.Any())&#13;&#10;            {&#13;&#10;                Console.WriteLine(&quot;\nTop 3 performers for N=10,000, Lookups=10,000:&quot;);&#13;&#10;                for (int i = 0; i &lt; largestScenario.Count; i++)&#13;&#10;                {&#13;&#10;                    var s = largestScenario[i];&#13;&#10;                    Console.WriteLine($&quot;{i+1}. {s.CollectionType}: {s.TotalMean:F1} μs (±{s.TotalStdDev:F1})&quot;);&#13;&#10;                }&#13;&#10;            }&#13;&#10;            &#13;&#10;            Console.WriteLine($&quot;\nFiles generated:&quot;);&#13;&#10;            Console.WriteLine($&quot;- Statistical Summary: {summaryPath}&quot;);&#13;&#10;            Console.WriteLine($&quot;- Performance Report: {reportPath}&quot;);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/StringCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/StringCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class StringCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringDictionary_CreationAndLookup()&#10;        {&#10;            var collection = stringSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringSortedDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new SortedDictionary&lt;string, bool&gt;(stringSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Readme6_Benchmark_Guid.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Readme6_Benchmark_Guid.md" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="# C# Collection Performance Benchmarks - GUID Data&#10;&#10;This document contains comprehensive performance benchmark results for various C# collection types using **GUID data**. The benchmarks were conducted using BenchmarkDotNet with multiple scenarios testing creation time, lookup time, and total time performance.&#10;&#10;## Test Scenarios&#10;&#10;- **Collection Types**: Array, List, HashSet, SortedSet, Dictionary, SortedDictionary, ConcurrentDictionary, ImmutableList, ImmutableHashSet&#10;- **Collection Sizes (N)**: 10, 100, 1,000, 10,000 elements&#10;- **Lookup Counts**: 10, 100, 1,000, 10,000 lookups per test&#10;- **Data Type**: System.Guid (16-byte structure)&#10;- **Sample Size**: 34 runs per scenario with outlier detection (Z-score &gt; 2.0)&#10;&#10;## Performance Summary by Collection Size&#10;&#10;### Small Collections (N=10)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.097 ±2.600 | 0.906 ±1.570 | 9.679 ±49.423 | 0.876 ±1.297 |&#10;| **List** | 1.127 ±2.159 | 1.039 ±1.560 | 1.453 ±3.740 | 0.985 ±1.416 |&#10;| **HashSet** | 2.136 ±2.266 | 2.009 ±2.200 | 2.206 ±2.734 | 2.133 ±1.891 |&#10;| **Dictionary** | 2.403 ±1.651 | 1.930 ±1.188 | 2.484 ±1.667 | 2.509 ±1.693 |&#10;| **SortedSet** | 3.518 ±1.718 | 3.358 ±1.547 | 3.312 ±1.491 | 3.527 ±1.907 |&#10;| **SortedDictionary** | 6.503 ±2.116 | 6.282 ±2.674 | 6.653 ±2.393 | 7.427 ±6.000 |&#10;| **ConcurrentDictionary** | 5.112 ±2.364 | 4.991 ±2.391 | 5.285 ±2.273 | 7.097 ±2.562 |&#10;| **ImmutableList** | 1.564 ±0.324 | 1.618 ±0.511 | 1.681 ±0.441 | 1.761 ±0.361 |&#10;| **ImmutableHashSet** | 4.930 ±2.261 | 5.215 ±2.429 | 5.916 ±3.488 | 5.764 ±2.416 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 0.515 ±0.162 | 1.618 ±0.140 | 20.667 ±17.124 | 100.136 ±3.294 |&#10;| **List** | 0.603 ±0.217 | 1.767 ±0.122 | 17.956 ±2.301 | 102.339 ±9.263 |&#10;| **HashSet** | 0.794 ±0.120 | 3.042 ±0.218 | 36.297 ±5.619 | 232.655 ±25.106 |&#10;| **Dictionary** | 0.791 ±0.245 | 3.370 ±0.410 | 43.950 ±10.034 | 233.985 ±32.116 |&#10;| **SortedSet** | 1.312 ±0.114 | 10.315 ±1.106 | 107.559 ±9.521 | 273.118 ±13.048 |&#10;| **SortedDictionary** | 1.448 ±0.137 | 15.879 ±4.655 | 121.469 ±15.976 | 365.952 ±19.721 |&#10;| **ConcurrentDictionary** | 0.630 ±0.064 | 2.597 ±0.126 | 64.545 ±189.899 | 138.497 ±19.543 |&#10;| **ImmutableList** | 0.767 ±0.183 | 6.852 ±0.194 | 80.047 ±2.537 | 646.509 ±13.673 |&#10;| **ImmutableHashSet** | 1.639 ±0.137 | 6.427 ±0.350 | 68.619 ±5.770 | 203.897 ±10.224 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.700 ±2.727 | 2.661 ±1.627 | 30.479 ±66.153 | 101.148 ±3.909 |&#10;| **List** | 1.824 ±2.296 | 2.888 ±1.664 | 19.544 ±4.484 | 103.442 ±9.202 |&#10;| **HashSet** | 3.055 ±2.367 | 5.124 ±2.295 | 38.622 ±6.053 | 234.873 ±26.591 |&#10;| **Dictionary** | 3.294 ±1.848 | 5.379 ±1.368 | 46.553 ±9.824 | 236.630 ±33.185 |&#10;| **SortedSet** | 4.927 ±1.760 | 13.776 ±1.874 | 110.972 ±9.014 | 276.748 ±13.963 |&#10;| **SortedDictionary** | 8.048 ±2.205 | 22.258 ±6.960 | 128.216 ±15.980 | 373.488 ±20.901 |&#10;| **ConcurrentDictionary** | 5.839 ±2.403 | 7.700 ±2.529 | 69.958 ±189.805 | 145.691 ±21.405 |&#10;| **ImmutableList** | 2.445 ±0.498 | 8.573 ±0.648 | 81.819 ±2.485 | 648.385 ±13.695 |&#10;| **ImmutableHashSet** | 6.697 ±2.349 | 11.752 ±2.451 | 74.656 ±5.816 | 209.770 ±11.535 |&#10;&#10;### Medium Collections (N=100)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.064 ±1.860 | 1.188 ±3.041 | 8.370 ±42.407 | 1.182 ±1.593 |&#10;| **List** | 1.145 ±2.139 | 2.355 ±7.278 | 1.237 ±2.630 | 1.248 ±1.533 |&#10;| **HashSet** | 5.045 ±2.490 | 4.312 ±1.651 | 5.572 ±3.480 | 4.888 ±2.308 |&#10;| **Dictionary** | 7.455 ±2.718 | 7.061 ±1.072 | 7.191 ±1.382 | 7.348 ±2.143 |&#10;| **SortedSet** | 17.103 ±3.259 | 19.127 ±3.560 | 21.934 ±3.574 | 18.276 ±2.673 |&#10;| **SortedDictionary** | 39.312 ±5.897 | 44.170 ±4.891 | 44.497 ±6.432 | 40.267 ±7.537 |&#10;| **ConcurrentDictionary** | 25.558 ±5.315 | 22.170 ±5.125 | 26.103 ±4.306 | 27.818 ±6.335 |&#10;| **ImmutableList** | 10.252 ±4.130 | 9.073 ±3.714 | 9.828 ±3.922 | 13.256 ±6.835 |&#10;| **ImmutableHashSet** | 36.630 ±3.828 | 36.336 ±3.973 | 37.856 ±5.554 | 39.164 ±6.832 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 0.833 ±0.145 | 6.015 ±3.597 | 67.976 ±14.669 | 673.397 ±13.880 |&#10;| **List** | 0.800 ±0.222 | 5.418 ±0.642 | 68.044 ±3.371 | 676.658 ±8.399 |&#10;| **HashSet** | 0.815 ±0.177 | 3.670 ±0.598 | 42.419 ±6.732 | 229.733 ±31.454 |&#10;| **Dictionary** | 0.891 ±0.095 | 4.424 ±0.123 | 44.737 ±8.315 | 262.558 ±29.738 |&#10;| **SortedSet** | 1.539 ±0.075 | 15.967 ±1.266 | 173.925 ±24.131 | 520.400 ±20.583 |&#10;| **SortedDictionary** | 1.958 ±0.192 | 21.521 ±3.559 | 217.059 ±9.568 | 662.642 ±15.592 |&#10;| **ConcurrentDictionary** | 0.997 ±2.192 | 3.321 ±0.464 | 69.864 ±201.956 | 187.421 ±25.181 |&#10;| **ImmutableList** | 3.500 ±0.256 | 38.852 ±2.144 | 598.666 ±15.401 | 6368.153 ±306.466 |&#10;| **ImmutableHashSet** | 2.173 ±0.123 | 16.761 ±0.632 | 107.475 ±10.807 | 365.258 ±10.248 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 2.015 ±2.003 | 7.309 ±4.765 | 76.452 ±56.991 | 674.709 ±13.872 |&#10;| **List** | 2.064 ±2.329 | 7.891 ±7.281 | 69.409 ±4.198 | 678.012 ±7.668 |&#10;| **HashSet** | 5.979 ±2.629 | 8.064 ±1.829 | 48.097 ±6.905 | 234.718 ±33.061 |&#10;| **Dictionary** | 8.476 ±2.741 | 11.576 ±1.059 | 52.047 ±8.078 | 270.030 ±31.387 |&#10;| **SortedSet** | 18.718 ±3.282 | 35.197 ±4.057 | 195.994 ±24.099 | 538.773 ±21.496 |&#10;| **SortedDictionary** | 41.364 ±6.051 | 65.809 ±7.608 | 261.678 ±11.865 | 703.018 ±17.137 |&#10;| **ConcurrentDictionary** | 26.658 ±6.942 | 25.570 ±5.305 | 96.058 ±201.913 | 215.339 ±26.147 |&#10;| **ImmutableList** | 13.861 ±4.192 | 48.039 ±3.521 | 608.613 ±16.102 | 6381.622 ±305.664 |&#10;| **ImmutableHashSet** | 38.930 ±3.851 | 53.197 ±4.097 | 145.466 ±9.711 | 404.536 ±11.550 |&#10;&#10;### Large Collections (N=1,000)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 9.745 ±4.402 | 10.567 ±4.891 | 17.776 ±46.709 | 11.467 ±4.305 |&#10;| **List** | 9.788 ±5.021 | 9.006 ±4.181 | 16.958 ±43.496 | 11.313 ±5.968 |&#10;| **HashSet** | 65.273 ±63.349 | 65.400 ±58.472 | 63.397 ±51.984 | 54.650 ±8.442 |&#10;| **Dictionary** | 103.630 ±93.195 | 100.270 ±80.378 | 88.412 ±15.207 | 90.512 ±70.994 |&#10;| **SortedSet** | 226.413 ±18.413 | 225.122 ±21.400 | 228.303 ±18.784 | 249.000 ±210.170 |&#10;| **SortedDictionary** | 497.406 ±28.427 | 494.944 ±24.903 | 493.144 ±19.086 | 485.573 ±226.642 |&#10;| **ConcurrentDictionary** | 227.531 ±204.828 | 211.000 ±203.146 | 237.163 ±222.822 | 224.994 ±180.366 |&#10;| **ImmutableList** | 43.797 ±10.168 | 47.403 ±9.206 | 88.452 ±200.881 | 38.783 ±20.324 |&#10;| **ImmutableHashSet** | 426.528 ±23.438 | 404.291 ±30.415 | 428.241 ±17.662 | 429.528 ±29.438 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 2.697 ±0.274 | 33.009 ±0.886 | 359.761 ±22.760 | 5201.291 ±231.903 |&#10;| **List** | 2.715 ±0.246 | 33.330 ±1.721 | 364.942 ±22.071 | 4837.858 ±209.534 |&#10;| **HashSet** | 10.015 ±52.883 | 12.273 ±47.272 | 50.288 ±44.618 | 252.125 ±29.058 |&#10;| **Dictionary** | 1.127 ±0.492 | 4.794 ±0.592 | 51.612 ±6.999 | 250.055 ±33.025 |&#10;| **SortedSet** | 2.513 ±0.134 | 24.609 ±2.377 | 220.219 ±19.362 | 873.591 ±50.577 |&#10;| **SortedDictionary** | 3.169 ±0.186 | 31.622 ±3.280 | 283.719 ±14.239 | 1029.936 ±28.397 |&#10;| **ConcurrentDictionary** | 0.816 ±0.081 | 3.044 ±0.251 | 35.794 ±3.478 | 185.331 ±18.282 |&#10;| **ImmutableList** | 25.500 ±0.853 | 403.303 ±10.641 | 4072.597 ±812.170 | 26736.600 ±4084.863 |&#10;| **ImmutableHashSet** | 2.572 ±0.161 | 19.794 ±1.690 | 204.438 ±16.261 | 625.972 ±39.525 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 12.770 ±4.747 | 43.855 ±5.603 | 377.900 ±65.950 | 5213.312 ±233.083 |&#10;| **List** | 12.958 ±5.573 | 42.570 ±5.114 | 382.100 ±64.808 | 4850.306 ±212.857 |&#10;| **HashSet** | 75.418 ±116.037 | 77.797 ±105.538 | 113.806 ±96.413 | 306.900 ±29.873 |&#10;| **Dictionary** | 107.812 ±94.111 | 107.479 ±81.396 | 142.562 ±21.348 | 342.394 ±78.658 |&#10;| **SortedSet** | 229.044 ±18.474 | 249.859 ±22.090 | 448.606 ±27.948 | 1122.700 ±209.059 |&#10;| **SortedDictionary** | 500.691 ±28.524 | 526.713 ±25.893 | 776.981 ±28.925 | 1515.618 ±232.510 |&#10;| **ConcurrentDictionary** | 228.463 ±204.863 | 214.147 ±203.331 | 273.066 ±222.395 | 410.397 ±181.870 |&#10;| **ImmutableList** | 69.400 ±10.279 | 450.803 ±14.787 | 4161.242 ±830.837 | 26775.724 ±4082.112 |&#10;| **ImmutableHashSet** | 429.209 ±23.507 | 424.184 ±30.186 | 632.791 ±26.381 | 1055.650 ±66.742 |&#10;&#10;### Very Large Collections (N=10,000)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 11.188 ±6.735 | 10.167 ±4.669 | 27.336 ±52.884 | 30.806 ±47.362 |&#10;| **List** | 9.012 ±3.261 | 9.812 ±5.090 | 24.663 ±44.333 | 30.447 ±45.339 |&#10;| **HashSet** | 160.155 ±13.120 | 173.497 ±8.346 | 167.391 ±13.092 | 163.645 ±13.485 |&#10;| **Dictionary** | 328.839 ±33.102 | 346.291 ±46.257 | 317.612 ±57.678 | 305.621 ±40.856 |&#10;| **SortedSet** | 1714.833 ±87.405 | 1748.673 ±79.526 | 1606.967 ±159.071 | 1631.691 ±211.321 |&#10;| **SortedDictionary** | 3652.870 ±1299.900 | 3757.633 ±1325.771 | 3767.158 ±1403.329 | 4230.864 ±721.919 |&#10;| **ConcurrentDictionary** | 1014.221 ±159.810 | 1032.242 ±244.584 | 1010.727 ±237.796 | 1034.473 ±249.256 |&#10;| **ImmutableList** | 253.067 ±27.206 | 275.473 ±121.176 | 167.521 ±162.094 | 191.294 ±217.176 |&#10;| **ImmutableHashSet** | 4381.403 ±219.880 | 3950.852 ±822.654 | 4364.779 ±219.156 | 4343.752 ±200.290 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 23.170 ±0.595 | 345.594 ±15.450 | 3718.727 ±115.120 | 38423.988 ±1414.425 |&#10;| **List** | 22.155 ±1.523 | 304.503 ±13.836 | 3616.784 ±178.327 | 39002.788 ±1472.814 |&#10;| **HashSet** | 0.797 ±0.129 | 5.282 ±4.888 | 66.633 ±139.879 | 319.018 ±42.283 |&#10;| **Dictionary** | 0.879 ±0.134 | 4.858 ±0.221 | 75.370 ±140.002 | 354.306 ±29.709 |&#10;| **SortedSet** | 3.306 ±0.270 | 33.785 ±2.964 | 290.061 ±174.129 | 1188.842 ±104.962 |&#10;| **SortedDictionary** | 4.342 ±1.524 | 31.976 ±11.506 | 334.315 ±219.781 | 1458.942 ±108.588 |&#10;| **ConcurrentDictionary** | 0.867 ±0.176 | 3.948 ±0.750 | 70.603 ±156.816 | 283.188 ±24.125 |&#10;| **ImmutableList** | 259.473 ±13.636 | 3544.363 ±491.538 | 18766.090 ±3566.817 | 177408.515 ±4821.124 |&#10;| **ImmutableHashSet** | 3.267 ±0.471 | 23.139 ±7.678 | 277.658 ±238.989 | 949.321 ±50.099 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 34.467 ±7.125 | 355.833 ±16.623 | 3746.270 ±131.741 | 38455.165 ±1423.152 |&#10;| **List** | 31.242 ±3.666 | 314.415 ±17.443 | 3641.625 ±174.221 | 39033.729 ±1482.034 |&#10;| **HashSet** | 161.042 ±13.205 | 178.873 ±9.801 | 234.170 ±138.676 | 482.755 ±51.359 |&#10;| **Dictionary** | 329.939 ±33.472 | 351.515 ±46.425 | 393.509 ±154.203 | 660.494 ±69.189 |&#10;| **SortedSet** | 1718.303 ±87.469 | 1782.633 ±78.174 | 1897.200 ±241.467 | 2820.721 ±255.789 |&#10;| **SortedDictionary** | 3657.506 ±1300.594 | 3789.836 ±1336.556 | 4101.676 ±1520.568 | 5690.148 ±805.170 |&#10;| **ConcurrentDictionary** | 1015.248 ±159.957 | 1036.330 ±244.712 | 1081.455 ±283.056 | 1317.824 ±266.472 |&#10;| **ImmutableList** | 512.627 ±32.886 | 3819.950 ±415.556 | 18933.883 ±3573.977 | 177600.191 ±4913.886 |&#10;| **ImmutableHashSet** | 4384.936 ±219.933 | 3974.209 ±829.218 | 4642.682 ±338.314 | 5293.276 ±235.757 |&#10;&#10;## Performance Champions by Scenario&#10;&#10;###  Small Collections (N=10) Winners&#10;- **10 Lookups**: List (1.8 μs) &gt; Array (1.7 μs) &gt; HashSet (3.1 μs)&#10;- **100 Lookups**: List (2.9 μs) &gt; Array (2.7 μs) &gt; HashSet (5.1 μs)&#10;- **1,000 Lookups**: List (19.5 μs) &gt; Array (30.5 μs) &gt; HashSet (38.6 μs)&#10;- **10,000 Lookups**: List (103.4 μs) &gt; Array (101.1 μs) &gt; ConcurrentDictionary (145.7 μs)&#10;&#10;###  Medium Collections (N=100) Winners&#10;- **10 Lookups**: Array (2.0 μs) &gt; List (2.1 μs) &gt; HashSet (6.0 μs)&#10;- **100 Lookups**: Array (7.3 μs) &gt; List (7.9 μs) &gt; HashSet (8.1 μs)&#10;- **1,000 Lookups**: HashSet (48.1 μs) &gt; Dictionary (52.0 μs) &gt; List (69.4 μs)&#10;- **10,000 Lookups**: ConcurrentDictionary (215.3 μs) &gt; HashSet (234.7 μs) &gt; Dictionary (270.0 μs)&#10;&#10;###  Large Collections (N=1,000) Winners&#10;- **10 Lookups**: Array (12.8 μs) &gt; List (13.0 μs) &gt; HashSet (75.4 μs)&#10;- **100 Lookups**: List (42.6 μs) &gt; Array (43.9 μs) &gt; HashSet (77.8 μs)&#10;- **1,000 Lookups**: HashSet (113.8 μs) &gt; Dictionary (142.6 μs) &gt; ConcurrentDictionary (273.1 μs)&#10;- **10,000 Lookups**: HashSet (306.9 μs) &gt; Dictionary (342.4 μs) &gt; ConcurrentDictionary (410.4 μs)&#10;&#10;###  Very Large Collections (N=10,000) Winners&#10;- **10 Lookups**: List (31.2 μs) &gt; Array (34.5 μs) &gt; HashSet (161.0 μs)&#10;- **100 Lookups**: List (314.4 μs) &gt; Dictionary (351.5 μs) &gt; Array (355.8 μs)&#10;- **1,000 Lookups**: HashSet (234.2 μs) &gt; Dictionary (393.5 μs) &gt; ConcurrentDictionary (1,081.5 μs)&#10;- **10,000 Lookups**: **HashSet (482.8 μs)** &gt; **Dictionary (660.5 μs)** &gt; **ConcurrentDictionary (1,317.8 μs)**&#10;&#10;## Performance Disasters&#10;&#10;### ⚠️ Critical Performance Issues&#10;- **ImmutableList N=10,000, 10,000 lookups**: 177,600 μs (177.6 seconds!)&#10;- **Array N=10,000, 10,000 lookups**: 38,455 μs (38.5 seconds)&#10;- **List N=10,000, 10,000 lookups**: 39,034 μs (39.0 seconds)&#10;&#10;###  Performance Ratios (vs HashSet at N=10,000, 10,000 lookups)&#10;- **ImmutableList**: 368x slower&#10;- **Array**: 80x slower  &#10;- **List**: 81x slower&#10;- **SortedDictionary**: 12x slower&#10;- **ImmutableHashSet**: 11x slower&#10;&#10;## GUID-Specific Characteristics&#10;&#10;###  Why GUIDs Perform Differently&#10;1. **Memory Overhead**: 16 bytes vs 4 bytes (integers) = 4x memory usage&#10;2. **Hash Complexity**: 128-bit values require more complex hashing&#10;3. **Cache Efficiency**: Larger memory footprint reduces CPU cache effectiveness&#10;4. **Comparison Cost**: More expensive equality comparisons than primitive types&#10;&#10;###  GUID vs Integer Performance Impact&#10;Based on comparing with integer benchmarks:&#10;- **HashSet**: ~55% slower for GUIDs&#10;- **Dictionary**: ~122% slower for GUIDs  &#10;- **Array/List**: ~300% slower for GUIDs&#10;- **Memory Usage**: ~4x higher for GUID collections&#10;&#10;## Statistical Reliability&#10;&#10;### ✅ Most Reliable Collections (Low CV%)&#10;- **HashSet**: Consistent across all scenarios&#10;- **Dictionary**: Reliable for medium-large collections&#10;- **SortedSet**: Good reliability for ordered data&#10;&#10;### ❌ Unreliable Collections (High CV%)&#10;- **Array/List**: High variability in small collections&#10;- **ConcurrentDictionary**: Very high variability due to threading overhead&#10;- **ImmutableList**: Unpredictable performance scaling&#10;&#10;## Recommendations&#10;&#10;### ✅ **Primary Choices for GUID Collections**&#10;&#10;**For Membership Testing:**&#10;- **HashSet** - Excellent O(1) performance, scales perfectly&#10;&#10;**For Key-Value Storage:**&#10;- **Dictionary** - Consistent performance, reasonable memory usage&#10;&#10;**For Thread-Safe Operations:**&#10;- **ConcurrentDictionary** - Actually performs best in largest scenarios&#10;&#10;### ❌ **Avoid for GUID Collections**&#10;&#10;**Never Use:**&#10;- **ImmutableList** - Catastrophically slow (177+ seconds)&#10;- **Array/List** - Only for sequential access, never for lookups&#10;&#10;**Use Only If Necessary:**&#10;- **SortedDictionary** - Only if you absolutely need sorted iteration&#10;- **ImmutableHashSet** - Only if immutability is required&#10;&#10;###  **Decision Matrix**&#10;&#10;| Scenario | Best Choice | Alternative | Avoid |&#10;|----------|-------------|-------------|-------|&#10;| Small collections (N&lt;100) | Array/List | HashSet | ImmutableList |&#10;| Medium collections (100-1000) | HashSet | Dictionary | Array/List |&#10;| Large collections (N&gt;1000) | HashSet | Dictionary | Everything else |&#10;| Thread-safe operations | ConcurrentDictionary | HashSet + locks | All others |&#10;| Key-value pairs needed | Dictionary | ConcurrentDictionary | SortedDictionary |&#10;&#10;## Conclusion&#10;&#10;For GUID collections, the choice of data structure has an enormous impact on performance. Hash-based collections (HashSet, Dictionary) are not just better - they are absolutely essential for any scenario involving frequent lookups with more than 1,000 elements. The performance difference can be the difference between sub-millisecond operations and multi-second delays." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Readme6_Benchmark_Integer.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Readme6_Benchmark_Integer.md" />
              <option name="originalContent" value="# C# Collection Performance Benchmarks&#10;&#10;This document contains comprehensive performance benchmark results for various C# collection types. The benchmarks were conducted using BenchmarkDotNet with multiple scenarios testing creation time, lookup time, and total time performance.&#10;&#10;## Test Scenarios&#10;&#10;- **Collection Types**: Array, List, HashSet, SortedSet, Dictionary, SortedDictionary, ConcurrentDictionary, ImmutableList, ImmutableHashSet&#10;- **Collection Sizes (N)**: 10, 100, 1,000, 10,000 elements&#10;- **Lookup Counts**: 10, 100, 1,000, 10,000 lookups per test&#10;- **Sample Size**: 34 runs per scenario with outlier detection (Z-score &gt; 2.0)&#10;&#10;## Performance Summary by Collection Size&#10;&#10;### Small Collections (N=10)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.18 ±2.44 | 1.12 ±2.19 | 0.93 ±1.92 | 1.07 ±1.99 |&#10;| **List** | 0.99 ±1.64 | 0.86 ±1.27 | 0.98 ±1.71 | 0.92 ±1.65 |&#10;| **HashSet** | 1.93 ±3.43 | 1.79 ±3.00 | 4.67 ±15.80 | 1.74 ±3.21 |&#10;| **Dictionary** | 1.77 ±1.33 | 1.82 ±1.96 | 1.91 ±3.09 | 1.90 ±1.29 |&#10;| **SortedSet** | 2.62 ±2.71 | 2.43 ±3.12 | 2.49 ±3.87 | 2.22 ±2.33 |&#10;| **SortedDictionary** | 6.16 ±3.60 | 5.19 ±2.73 | 5.38 ±2.71 | 6.08 ±3.03 |&#10;| **ConcurrentDictionary** | 5.22 ±2.65 | 5.63 ±3.84 | 5.89 ±4.69 | 6.62 ±3.75 |&#10;| **ImmutableList** | 1.63 ±0.34 | 1.40 ±0.21 | 1.84 ±1.37 | 2.11 ±2.77 |&#10;| **ImmutableHashSet** | 4.69 ±2.21 | 4.07 ±1.57 | 4.31 ±2.16 | 4.41 ±2.30 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 0.30 ±0.12 | 1.09 ±0.15 | 10.59 ±1.66 | 37.22 ±2.80 |&#10;| **List** | 0.38 ±0.17 | 1.18 ±0.13 | 12.36 ±2.23 | 37.44 ±2.35 |&#10;| **HashSet** | 0.27 ±0.07 | 1.49 ±0.12 | 17.17 ±1.96 | 98.02 ±4.55 |&#10;| **Dictionary** | 0.33 ±0.05 | 1.59 ±0.17 | 17.00 ±1.96 | 106.30 ±7.50 |&#10;| **SortedSet** | 1.22 ±0.12 | 8.88 ±1.05 | 81.35 ±5.73 | 186.58 ±9.28 |&#10;| **SortedDictionary** | 1.32 ±0.10 | 8.69 ±0.89 | 86.10 ±5.76 | 234.73 ±18.96 |&#10;| **ConcurrentDictionary** | 0.38 ±0.05 | 2.18 ±0.12 | 25.20 ±4.62 | 129.88 ±21.05 |&#10;| **ImmutableList** | 1.04 ±0.12 | 6.38 ±0.34 | 71.66 ±3.33 | 550.93 ±34.79 |&#10;| **ImmutableHashSet** | 0.79 ±0.08 | 5.48 ±0.22 | 93.23 ±195.38 | 162.55 ±8.12 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.58 ±2.52 | 2.36 ±2.25 | 11.59 ±2.28 | 38.38 ±4.42 |&#10;| **List** | 1.48 ±1.78 | 2.14 ±1.33 | 13.48 ±2.64 | 38.46 ±3.68 |&#10;| **HashSet** | 2.29 ±3.50 | 3.37 ±3.04 | 21.92 ±15.83 | 99.83 ±7.23 |&#10;| **Dictionary** | 2.20 ±1.35 | 3.53 ±2.06 | 19.03 ±3.18 | 108.30 ±7.69 |&#10;| **SortedSet** | 3.94 ±2.79 | 11.43 ±3.72 | 83.95 ±5.50 | 188.90 ±9.95 |&#10;| **SortedDictionary** | 7.60 ±3.62 | 13.98 ±2.78 | 91.59 ±5.55 | 240.92 ±20.62 |&#10;| **ConcurrentDictionary** | 5.70 ±2.67 | 7.90 ±3.91 | 31.18 ±6.17 | 136.58 ±23.97 |&#10;| **ImmutableList** | 2.77 ±0.41 | 7.88 ±0.46 | 73.61 ±2.92 | 553.12 ±35.81 |&#10;| **ImmutableHashSet** | 5.57 ±2.22 | 9.66 ±1.64 | 97.63 ±195.37 | 167.06 ±9.32 |&#10;&#10;### Medium Collections (N=100)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.18 ±2.48 | 1.22 ±2.37 | 1.07 ±2.14 | 1.38 ±2.47 |&#10;| **List** | 1.10 ±1.85 | 0.81 ±1.34 | 1.06 ±1.62 | 1.04 ±1.41 |&#10;| **HashSet** | 2.71 ±3.09 | 3.02 ±4.05 | 5.81 ±16.27 | 3.70 ±5.72 |&#10;| **Dictionary** | 4.36 ±1.30 | 4.64 ±1.67 | 4.81 ±3.71 | 4.90 ±1.11 |&#10;| **SortedSet** | 11.40 ±4.69 | 12.52 ±4.79 | 10.02 ±3.59 | 11.88 ±4.55 |&#10;| **SortedDictionary** | 32.69 ±4.61 | 32.32 ±5.26 | 35.73 ±5.72 | 37.36 ±4.22 |&#10;| **ConcurrentDictionary** | 17.42 ±2.95 | 18.55 ±5.06 | 18.70 ±5.10 | 21.58 ±6.03 |&#10;| **ImmutableList** | 7.02 ±3.43 | 7.77 ±3.67 | 9.75 ±4.05 | 42.65 ±201.03 |&#10;| **ImmutableHashSet** | 32.44 ±9.10 | 31.09 ±3.59 | 34.41 ±3.61 | 32.48 ±4.73 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 0.41 ±0.11 | 1.47 ±0.14 | 16.80 ±2.36 | 119.82 ±6.86 |&#10;| **List** | 0.59 ±0.20 | 1.45 ±0.15 | 18.53 ±2.77 | 108.64 ±7.97 |&#10;| **HashSet** | 0.31 ±0.07 | 1.54 ±0.17 | 17.75 ±2.10 | 117.18 ±4.14 |&#10;| **Dictionary** | 0.32 ±0.06 | 1.54 ±0.10 | 17.34 ±2.25 | 119.86 ±4.44 |&#10;| **SortedSet** | 1.71 ±0.14 | 16.96 ±1.55 | 137.26 ±8.66 | 372.12 ±20.36 |&#10;| **SortedDictionary** | 1.96 ±0.98 | 17.25 ±1.45 | 170.13 ±15.31 | 515.59 ±8.63 |&#10;| **ConcurrentDictionary** | 0.46 ±0.07 | 2.39 ±0.14 | 28.79 ±4.44 | 177.26 ±22.26 |&#10;| **ImmutableList** | 5.98 ±0.29 | 56.72 ±5.95 | 611.68 ±27.09 | 4409.84 ±1663.93 |&#10;| **ImmutableHashSet** | 1.08 ±0.08 | 9.56 ±1.36 | 98.19 ±10.76 | 300.62 ±30.76 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.69 ±2.54 | 2.79 ±2.43 | 17.98 ±2.67 | 121.31 ±7.56 |&#10;| **List** | 1.79 ±1.96 | 2.34 ±1.43 | 19.69 ±2.83 | 109.79 ±8.90 |&#10;| **HashSet** | 3.08 ±3.10 | 4.66 ±4.15 | 23.65 ±16.15 | 121.00 ±7.63 |&#10;| **Dictionary** | 4.79 ±1.30 | 6.28 ±1.71 | 22.25 ±3.91 | 124.85 ±4.98 |&#10;| **SortedSet** | 13.22 ±4.71 | 29.58 ±5.22 | 147.35 ±9.16 | 384.11 ±21.77 |&#10;| **SortedDictionary** | 34.78 ±4.54 | 49.67 ±5.93 | 205.95 ±16.06 | 553.06 ±8.43 |&#10;| **ConcurrentDictionary** | 19.64 ±3.27 | 22.36 ±5.56 | 50.04 ±6.58 | 200.97 ±25.56 |&#10;| **ImmutableList** | 13.10 ±3.53 | 64.58 ±6.28 | 621.53 ±29.69 | 4452.63 ±1722.88 |&#10;| **ImmutableHashSet** | 33.62 ±9.13 | 40.75 ±4.01 | 132.71 ±9.82 | 333.18 ±30.86 |&#10;&#10;### Large Collections (N=1,000)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 9.42 ±5.87 | 5.95 ±3.07 | 6.41 ±3.93 | 8.37 ±4.99 |&#10;| **List** | 7.39 ±4.58 | 5.93 ±2.90 | 7.90 ±3.39 | 6.48 ±3.51 |&#10;| **HashSet** | 26.26 ±6.14 | 26.13 ±6.42 | 29.93 ±16.99 | 27.78 ±6.00 |&#10;| **Dictionary** | 51.48 ±6.71 | 52.21 ±7.51 | 55.53 ±10.28 | 69.00 ±88.14 |&#10;| **SortedSet** | 76.41 ±10.74 | 81.39 ±8.77 | 88.96 ±13.16 | 106.19 ±155.55 |&#10;| **SortedDictionary** | 357.69 ±22.88 | 363.27 ±22.99 | 405.17 ±25.59 | 455.99 ±264.17 |&#10;| **ConcurrentDictionary** | 170.44 ±24.89 | 182.49 ±175.07 | 194.56 ±206.45 | 216.94 ±247.72 |&#10;| **ImmutableList** | 39.38 ±7.49 | 40.48 ±7.30 | 80.61 ±217.69 | 38.86 ±17.37 |&#10;| **ImmutableHashSet** | 376.04 ±23.62 | 391.73 ±31.70 | 510.66 ±521.26 | 387.23 ±27.47 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.46 ±0.23 | 9.94 ±0.10 | 114.43 ±2.62 | 1075.43 ±35.20 |&#10;| **List** | 1.30 ±0.15 | 10.12 ±0.82 | 114.63 ±2.54 | 962.67 ±19.42 |&#10;| **HashSet** | 0.32 ±0.09 | 1.65 ±0.13 | 19.29 ±2.42 | 118.55 ±5.40 |&#10;| **Dictionary** | 0.41 ±0.06 | 1.88 ±0.13 | 19.24 ±3.91 | 121.38 ±6.33 |&#10;| **SortedSet** | 2.21 ±0.14 | 24.26 ±2.25 | 220.51 ±18.33 | 602.66 ±39.28 |&#10;| **SortedDictionary** | 2.40 ±0.11 | 24.84 ±1.91 | 246.93 ±18.71 | 811.43 ±19.58 |&#10;| **ConcurrentDictionary** | 0.53 ±0.07 | 2.41 ±0.11 | 29.36 ±4.43 | 177.94 ±23.42 |&#10;| **ImmutableList** | 55.12 ±3.93 | 545.80 ±9.32 | 4427.22 ±1622.43 | 21691.81 ±2126.67 |&#10;| **ImmutableHashSet** | 1.37 ±0.11 | 14.43 ±1.91 | 134.31 ±20.62 | 491.20 ±27.48 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 10.99 ±6.03 | 15.97 ±3.08 | 120.95 ±3.78 | 1083.92 ±33.72 |&#10;| **List** | 8.79 ±4.64 | 16.14 ±2.80 | 122.63 ±4.78 | 969.24 ±20.35 |&#10;| **HashSet** | 26.68 ±6.13 | 27.92 ±6.41 | 49.32 ±17.42 | 146.41 ±7.43 |&#10;| **Dictionary** | 54.11 ±7.36 | 56.50 ±8.42 | 77.34 ±12.72 | 192.78 ±88.87 |&#10;| **SortedSet** | 78.69 ±10.81 | 105.73 ±9.96 | 309.57 ±23.88 | 708.95 ±168.44 |&#10;| **SortedDictionary** | 360.21 ±22.88 | 388.20 ±21.99 | 652.22 ±38.91 | 1267.56 ±264.41 |&#10;| **ConcurrentDictionary** | 171.09 ±24.92 | 184.98 ±175.12 | 224.01 ±206.06 | 394.99 ±254.26 |&#10;| **ImmutableList** | 94.59 ±10.23 | 586.38 ±10.52 | 4507.97 ±1678.56 | 21730.91 ±2124.38 |&#10;| **ImmutableHashSet** | 377.52 ±23.68 | 406.25 ±30.56 | 645.12 ±537.61 | 878.53 ±51.39 |&#10;&#10;### Very Large Collections (N=10,000)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 16.36 ±8.46 | 17.98 ±6.27 | 16.83 ±6.81 | 21.22 ±13.84 |&#10;| **List** | 17.47 ±5.88 | 16.14 ±4.87 | 17.40 ±7.40 | 16.38 ±16.20 |&#10;| **HashSet** | 143.58 ±12.18 | 138.79 ±11.76 | 135.04 ±20.94 | 130.00 ±9.28 |&#10;| **Dictionary** | 148.32 ±9.31 | 131.94 ±12.39 | 145.49 ±6.13 | 130.86 ±7.98 |&#10;| **SortedSet** | 549.51 ±35.26 | 533.23 ±30.93 | 557.61 ±31.90 | 534.08 ±37.02 |&#10;| **SortedDictionary** | 4338.02 ±163.32 | 3789.63 ±194.53 | 4003.85 ±196.62 | 3946.77 ±246.12 |&#10;| **ConcurrentDictionary** | 699.76 ±94.36 | 589.26 ±53.70 | 654.51 ±49.36 | 590.72 ±47.79 |&#10;| **ImmutableList** | 244.16 ±6.78 | 234.58 ±265.78 | 151.08 ±159.87 | 171.08 ±204.33 |&#10;| **ImmutableHashSet** | 3981.00 ±228.55 | 3641.79 ±813.67 | 3765.74 ±842.47 | 3358.86 ±863.95 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 8.98 ±0.83 | 96.71 ±7.11 | 854.99 ±14.03 | 7745.85 ±2014.02 |&#10;| **List** | 9.89 ±0.50 | 97.19 ±10.01 | 869.81 ±38.74 | 6455.15 ±2250.71 |&#10;| **HashSet** | 0.32 ±0.09 | 1.86 ±0.12 | 19.71 ±2.57 | 122.18 ±7.40 |&#10;| **Dictionary** | 0.40 ±0.07 | 1.81 ±0.15 | 21.67 ±6.24 | 119.36 ±3.00 |&#10;| **SortedSet** | 2.95 ±0.22 | 30.03 ±3.21 | 262.58 ±13.96 | 904.04 ±55.88 |&#10;| **SortedDictionary** | 4.36 ±0.81 | 32.04 ±3.11 | 331.24 ±192.02 | 1120.07 ±68.75 |&#10;| **ConcurrentDictionary** | 0.89 ±0.43 | 2.62 ±0.10 | 60.91 ±163.83 | 174.76 ±22.24 |&#10;| **ImmutableList** | 594.55 ±17.11 | 4332.47 ±1460.85 | 21239.72 ±1006.84 | 198042.57 ±4948.98 |&#10;| **ImmutableHashSet** | 2.24 ±0.51 | 18.65 ±7.14 | 196.45 ±237.84 | 842.16 ±62.56 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 25.66 ±8.90 | 114.85 ±9.11 | 871.92 ±15.31 | 7767.38 ±2016.53 |&#10;| **List** | 27.44 ±5.94 | 113.51 ±11.33 | 887.31 ±38.91 | 6472.14 ±2258.04 |&#10;| **HashSet** | 144.00 ±12.21 | 140.76 ±11.83 | 154.87 ±21.39 | 252.27 ±14.47 |&#10;| **Dictionary** | 149.24 ±9.22 | 134.08 ±12.65 | 167.65 ±8.45 | 250.47 ±9.87 |&#10;| **SortedSet** | 552.56 ±35.37 | 563.34 ±32.14 | 820.26 ±38.82 | 1438.20 ±88.70 |&#10;| **SortedDictionary** | 4342.99 ±163.66 | 3821.83 ±196.13 | 4335.23 ±262.39 | 5067.04 ±306.56 |&#10;| **ConcurrentDictionary** | 700.83 ±94.79 | 591.98 ±53.78 | 715.52 ±166.90 | 765.60 ±67.83 |&#10;| **ImmutableList** | 838.86 ±20.71 | 4567.22 ±1574.60 | 21391.03 ±1052.32 | 198214.07 ±4928.54 |&#10;| **ImmutableHashSet** | 3983.41 ±228.63 | 3660.62 ±817.27 | 3962.36 ±922.61 | 4201.21 ±862.65 |&#10;&#10;## Key Performance Insights&#10;&#10;###  Best Performers by Category&#10;&#10;#### Creation Time Champions&#10;- **Small collections (N≤100)**: Array and List (sub-microsecond performance)&#10;- **Large collections (N≥1,000)**: Array and List maintain excellent creation performance&#10;&#10;#### Lookup Time Champions&#10;- **Hash-based lookups**: HashSet and Dictionary show O(1) performance across all scales&#10;- **Sequential access**: Array and List excel for small lookup counts&#10;- **Sorted access**: SortedSet and SortedDictionary provide O(log n) performance&#10;&#10;#### Total Performance Winners&#10;- **Small workloads**: Array and List dominate&#10;- **Medium workloads**: HashSet and Dictionary take the lead&#10;- **Large workloads**: Hash-based collections maintain superiority&#10;&#10;###  Performance Patterns&#10;&#10;1. **Scalability**: Hash-based collections (HashSet, Dictionary) show excellent scalability&#10;2. **Consistency**: Array and List provide very consistent performance with low variance&#10;3. **Thread Safety Cost**: ConcurrentDictionary shows ~2-3x overhead compared to Dictionary&#10;4. **Immutability Cost**: Immutable collections show significant performance penalties, especially for large datasets&#10;5. **Sorted Structure Cost**: SortedSet and SortedDictionary have higher overhead but provide ordering guarantees&#10;&#10;### ⚠️ Performance Warnings&#10;&#10;- **ImmutableList**: Shows exponential degradation with size, unsuitable for large collections&#10;- **Large sorted collections**: SortedDictionary creation time becomes prohibitive at N=10,000&#10;- **High lookup counts**: Sequential collections (Array, List) become inefficient for many lookups&#10;&#10;---&#10;&#10;*Statistics format: Mean ±Standard Deviation (all times in microseconds)*&#10;*Outliers removed using Z-score &gt; 2.0 threshold*" />
              <option name="updatedContent" value="# C# Collection Performance Benchmarks&#10;&#10;This document contains comprehensive performance benchmark results for various C# collection types. The benchmarks were conducted using BenchmarkDotNet with multiple scenarios testing creation time, lookup time, and total time performance.&#10;&#10;## Test Scenarios&#10;&#10;- **Collection Types**: Array, List, HashSet, SortedSet, Dictionary, SortedDictionary, ConcurrentDictionary, ImmutableList, ImmutableHashSet&#10;- **Collection Sizes (N)**: 10, 100, 1,000, 10,000 elements&#10;- **Lookup Counts**: 10, 100, 1,000, 10,000 lookups per test&#10;- **Sample Size**: 34 runs per scenario with outlier detection (Z-score &gt; 2.0)&#10;&#10;## Performance Summary by Collection Size&#10;&#10;### Small Collections (N=10)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.18 ±2.44 | 1.12 ±2.19 | 0.93 ±1.92 | 1.07 ±1.99 |&#10;| **List** | 0.99 ±1.64 | 0.86 ±1.27 | 0.98 ±1.71 | 0.92 ±1.65 |&#10;| **HashSet** | 1.93 ±3.43 | 1.79 ±3.00 | 4.67 ±15.80 | 1.74 ±3.21 |&#10;| **Dictionary** | 1.77 ±1.33 | 1.82 ±1.96 | 1.91 ±3.09 | 1.90 ±1.29 |&#10;| **SortedSet** | 2.62 ±2.71 | 2.43 ±3.12 | 2.49 ±3.87 | 2.22 ±2.33 |&#10;| **SortedDictionary** | 6.16 ±3.60 | 5.19 ±2.73 | 5.38 ±2.71 | 6.08 ±3.03 |&#10;| **ConcurrentDictionary** | 5.22 ±2.65 | 5.63 ±3.84 | 5.89 ±4.69 | 6.62 ±3.75 |&#10;| **ImmutableList** | 1.63 ±0.34 | 1.40 ±0.21 | 1.84 ±1.37 | 2.11 ±2.77 |&#10;| **ImmutableHashSet** | 4.69 ±2.21 | 4.07 ±1.57 | 4.31 ±2.16 | 4.41 ±2.30 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 0.30 ±0.12 | 1.09 ±0.15 | 10.59 ±1.66 | 37.22 ±2.80 |&#10;| **List** | 0.38 ±0.17 | 1.18 ±0.13 | 12.36 ±2.23 | 37.44 ±2.35 |&#10;| **HashSet** | 0.27 ±0.07 | 1.49 ±0.12 | 17.17 ±1.96 | 98.02 ±4.55 |&#10;| **Dictionary** | 0.33 ±0.05 | 1.59 ±0.17 | 17.00 ±1.96 | 106.30 ±7.50 |&#10;| **SortedSet** | 1.22 ±0.12 | 8.88 ±1.05 | 81.35 ±5.73 | 186.58 ±9.28 |&#10;| **SortedDictionary** | 1.32 ±0.10 | 8.69 ±0.89 | 86.10 ±5.76 | 234.73 ±18.96 |&#10;| **ConcurrentDictionary** | 0.38 ±0.05 | 2.18 ±0.12 | 25.20 ±4.62 | 129.88 ±21.05 |&#10;| **ImmutableList** | 1.04 ±0.12 | 6.38 ±0.34 | 71.66 ±3.33 | 550.93 ±34.79 |&#10;| **ImmutableHashSet** | 0.79 ±0.08 | 5.48 ±0.22 | 93.23 ±195.38 | 162.55 ±8.12 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.58 ±2.52 | 2.36 ±2.25 | 11.59 ±2.28 | 38.38 ±4.42 |&#10;| **List** | 1.48 ±1.78 | 2.14 ±1.33 | 13.48 ±2.64 | 38.46 ±3.68 |&#10;| **HashSet** | 2.29 ±3.50 | 3.37 ±3.04 | 21.92 ±15.83 | 99.83 ±7.23 |&#10;| **Dictionary** | 2.20 ±1.35 | 3.53 ±2.06 | 19.03 ±3.18 | 108.30 ±7.69 |&#10;| **SortedSet** | 3.94 ±2.79 | 11.43 ±3.72 | 83.95 ±5.50 | 188.90 ±9.95 |&#10;| **SortedDictionary** | 7.60 ±3.62 | 13.98 ±2.78 | 91.59 ±5.55 | 240.92 ±20.62 |&#10;| **ConcurrentDictionary** | 5.70 ±2.67 | 7.90 ±3.91 | 31.18 ±6.17 | 136.58 ±23.97 |&#10;| **ImmutableList** | 2.77 ±0.41 | 7.88 ±0.46 | 73.61 ±2.92 | 553.12 ±35.81 |&#10;| **ImmutableHashSet** | 5.57 ±2.22 | 9.66 ±1.64 | 97.63 ±195.37 | 167.06 ±9.32 |&#10;&#10;### Medium Collections (N=100)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.18 ±2.48 | 1.22 ±2.37 | 1.07 ±2.14 | 1.38 ±2.47 |&#10;| **List** | 1.10 ±1.85 | 0.81 ±1.34 | 1.06 ±1.62 | 1.04 ±1.41 |&#10;| **HashSet** | 2.71 ±3.09 | 3.02 ±4.05 | 5.81 ±16.27 | 3.70 ±5.72 |&#10;| **Dictionary** | 4.36 ±1.30 | 4.64 ±1.67 | 4.81 ±3.71 | 4.90 ±1.11 |&#10;| **SortedSet** | 11.40 ±4.69 | 12.52 ±4.79 | 10.02 ±3.59 | 11.88 ±4.55 |&#10;| **SortedDictionary** | 32.69 ±4.61 | 32.32 ±5.26 | 35.73 ±5.72 | 37.36 ±4.22 |&#10;| **ConcurrentDictionary** | 17.42 ±2.95 | 18.55 ±5.06 | 18.70 ±5.10 | 21.58 ±6.03 |&#10;| **ImmutableList** | 7.02 ±3.43 | 7.77 ±3.67 | 9.75 ±4.05 | 42.65 ±201.03 |&#10;| **ImmutableHashSet** | 32.44 ±9.10 | 31.09 ±3.59 | 34.41 ±3.61 | 32.48 ±4.73 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 0.41 ±0.11 | 1.47 ±0.14 | 16.80 ±2.36 | 119.82 ±6.86 |&#10;| **List** | 0.59 ±0.20 | 1.45 ±0.15 | 18.53 ±2.77 | 108.64 ±7.97 |&#10;| **HashSet** | 0.31 ±0.07 | 1.54 ±0.17 | 17.75 ±2.10 | 117.18 ±4.14 |&#10;| **Dictionary** | 0.32 ±0.06 | 1.54 ±0.10 | 17.34 ±2.25 | 119.86 ±4.44 |&#10;| **SortedSet** | 1.71 ±0.14 | 16.96 ±1.55 | 137.26 ±8.66 | 372.12 ±20.36 |&#10;| **SortedDictionary** | 1.96 ±0.98 | 17.25 ±1.45 | 170.13 ±15.31 | 515.59 ±8.63 |&#10;| **ConcurrentDictionary** | 0.46 ±0.07 | 2.39 ±0.14 | 28.79 ±4.44 | 177.26 ±22.26 |&#10;| **ImmutableList** | 5.98 ±0.29 | 56.72 ±5.95 | 611.68 ±27.09 | 4409.84 ±1663.93 |&#10;| **ImmutableHashSet** | 1.08 ±0.08 | 9.56 ±1.36 | 98.19 ±10.76 | 300.62 ±30.76 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.69 ±2.54 | 2.79 ±2.43 | 17.98 ±2.67 | 121.31 ±7.56 |&#10;| **List** | 1.79 ±1.96 | 2.34 ±1.43 | 19.69 ±2.83 | 109.79 ±8.90 |&#10;| **HashSet** | 3.08 ±3.10 | 4.66 ±4.15 | 23.65 ±16.15 | 121.00 ±7.63 |&#10;| **Dictionary** | 4.79 ±1.30 | 6.28 ±1.71 | 22.25 ±3.91 | 124.85 ±4.98 |&#10;| **SortedSet** | 13.22 ±4.71 | 29.58 ±5.22 | 147.35 ±9.16 | 384.11 ±21.77 |&#10;| **SortedDictionary** | 34.78 ±4.54 | 49.67 ±5.93 | 205.95 ±16.06 | 553.06 ±8.43 |&#10;| **ConcurrentDictionary** | 19.64 ±3.27 | 22.36 ±5.56 | 50.04 ±6.58 | 200.97 ±25.56 |&#10;| **ImmutableList** | 13.10 ±3.53 | 64.58 ±6.28 | 621.53 ±29.69 | 4452.63 ±1722.88 |&#10;| **ImmutableHashSet** | 33.62 ±9.13 | 40.75 ±4.01 | 132.71 ±9.82 | 333.18 ±30.86 |&#10;&#10;### Large Collections (N=1,000)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 9.42 ±5.87 | 5.95 ±3.07 | 6.41 ±3.93 | 8.37 ±4.99 |&#10;| **List** | 7.39 ±4.58 | 5.93 ±2.90 | 7.90 ±3.39 | 6.48 ±3.51 |&#10;| **HashSet** | 26.26 ±6.14 | 26.13 ±6.42 | 29.93 ±16.99 | 27.78 ±6.00 |&#10;| **Dictionary** | 51.48 ±6.71 | 52.21 ±7.51 | 55.53 ±10.28 | 69.00 ±88.14 |&#10;| **SortedSet** | 76.41 ±10.74 | 81.39 ±8.77 | 88.96 ±13.16 | 106.19 ±155.55 |&#10;| **SortedDictionary** | 357.69 ±22.88 | 363.27 ±22.99 | 405.17 ±25.59 | 455.99 ±264.17 |&#10;| **ConcurrentDictionary** | 170.44 ±24.89 | 182.49 ±175.07 | 194.56 ±206.45 | 216.94 ±247.72 |&#10;| **ImmutableList** | 39.38 ±7.49 | 40.48 ±7.30 | 80.61 ±217.69 | 38.86 ±17.37 |&#10;| **ImmutableHashSet** | 376.04 ±23.62 | 391.73 ±31.70 | 510.66 ±521.26 | 387.23 ±27.47 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.46 ±0.23 | 9.94 ±0.10 | 114.43 ±2.62 | 1075.43 ±35.20 |&#10;| **List** | 1.30 ±0.15 | 10.12 ±0.82 | 114.63 ±2.54 | 962.67 ±19.42 |&#10;| **HashSet** | 0.32 ±0.09 | 1.65 ±0.13 | 19.29 ±2.42 | 118.55 ±5.40 |&#10;| **Dictionary** | 0.41 ±0.06 | 1.88 ±0.13 | 19.24 ±3.91 | 121.38 ±6.33 |&#10;| **SortedSet** | 2.21 ±0.14 | 24.26 ±2.25 | 220.51 ±18.33 | 602.66 ±39.28 |&#10;| **SortedDictionary** | 2.40 ±0.11 | 24.84 ±1.91 | 246.93 ±18.71 | 811.43 ±19.58 |&#10;| **ConcurrentDictionary** | 0.53 ±0.07 | 2.41 ±0.11 | 29.36 ±4.43 | 177.94 ±23.42 |&#10;| **ImmutableList** | 55.12 ±3.93 | 545.80 ±9.32 | 4427.22 ±1622.43 | 21691.81 ±2126.67 |&#10;| **ImmutableHashSet** | 1.37 ±0.11 | 14.43 ±1.91 | 134.31 ±20.62 | 491.20 ±27.48 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 10.99 ±6.03 | 15.97 ±3.08 | 120.95 ±3.78 | 1083.92 ±33.72 |&#10;| **List** | 8.79 ±4.64 | 16.14 ±2.80 | 122.63 ±4.78 | 969.24 ±20.35 |&#10;| **HashSet** | 26.68 ±6.13 | 27.92 ±6.41 | 49.32 ±17.42 | 146.41 ±7.43 |&#10;| **Dictionary** | 54.11 ±7.36 | 56.50 ±8.42 | 77.34 ±12.72 | 192.78 ±88.87 |&#10;| **SortedSet** | 78.69 ±10.81 | 105.73 ±9.96 | 309.57 ±23.88 | 708.95 ±168.44 |&#10;| **SortedDictionary** | 360.21 ±22.88 | 388.20 ±21.99 | 652.22 ±38.91 | 1267.56 ±264.41 |&#10;| **ConcurrentDictionary** | 171.09 ±24.92 | 184.98 ±175.12 | 224.01 ±206.06 | 394.99 ±254.26 |&#10;| **ImmutableList** | 94.59 ±10.23 | 586.38 ±10.52 | 4507.97 ±1678.56 | 21730.91 ±2124.38 |&#10;| **ImmutableHashSet** | 377.52 ±23.68 | 406.25 ±30.56 | 645.12 ±537.61 | 878.53 ±51.39 |&#10;&#10;### Very Large Collections (N=10,000)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 16.36 ±8.46 | 17.98 ±6.27 | 16.83 ±6.81 | 21.22 ±13.84 |&#10;| **List** | 17.47 ±5.88 | 16.14 ±4.87 | 17.40 ±7.40 | 16.38 ±16.20 |&#10;| **HashSet** | 143.58 ±12.18 | 138.79 ±11.76 | 135.04 ±20.94 | 130.00 ±9.28 |&#10;| **Dictionary** | 148.32 ±9.31 | 131.94 ±12.39 | 145.49 ±6.13 | 130.86 ±7.98 |&#10;| **SortedSet** | 549.51 ±35.26 | 533.23 ±30.93 | 557.61 ±31.90 | 534.08 ±37.02 |&#10;| **SortedDictionary** | 4338.02 ±163.32 | 3789.63 ±194.53 | 4003.85 ±196.62 | 3946.77 ±246.12 |&#10;| **ConcurrentDictionary** | 699.76 ±94.36 | 589.26 ±53.70 | 654.51 ±49.36 | 590.72 ±47.79 |&#10;| **ImmutableList** | 244.16 ±6.78 | 234.58 ±265.78 | 151.08 ±159.87 | 171.08 ±204.33 |&#10;| **ImmutableHashSet** | 3981.00 ±228.55 | 3641.79 ±813.67 | 3765.74 ±842.47 | 3358.86 ±863.95 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 8.98 ±0.83 | 96.71 ±7.11 | 854.99 ±14.03 | 7745.85 ±2014.02 |&#10;| **List** | 9.89 ±0.50 | 97.19 ±10.01 | 869.81 ±38.74 | 6455.15 ±2250.71 |&#10;| **HashSet** | 0.32 ±0.09 | 1.86 ±0.12 | 19.71 ±2.57 | 122.18 ±7.40 |&#10;| **Dictionary** | 0.40 ±0.07 | 1.81 ±0.15 | 21.67 ±6.24 | 119.36 ±3.00 |&#10;| **SortedSet** | 2.95 ±0.22 | 30.03 ±3.21 | 262.58 ±13.96 | 904.04 ±55.88 |&#10;| **SortedDictionary** | 4.36 ±0.81 | 32.04 ±3.11 | 331.24 ±192.02 | 1120.07 ±68.75 |&#10;| **ConcurrentDictionary** | 0.89 ±0.43 | 2.62 ±0.10 | 60.91 ±163.83 | 174.76 ±22.24 |&#10;| **ImmutableList** | 594.55 ±17.11 | 4332.47 ±1460.85 | 21239.72 ±1006.84 | 198042.57 ±4948.98 |&#10;| **ImmutableHashSet** | 2.24 ±0.51 | 18.65 ±7.14 | 196.45 ±237.84 | 842.16 ±62.56 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 25.66 ±8.90 | 114.85 ±9.11 | 871.92 ±15.31 | 7767.38 ±2016.53 |&#10;| **List** | 27.44 ±5.94 | 113.51 ±11.33 | 887.31 ±38.91 | 6472.14 ±2258.04 |&#10;| **HashSet** | 144.00 ±12.21 | 140.76 ±11.83 | 154.87 ±21.39 | 252.27 ±14.47 |&#10;| **Dictionary** | 149.24 ±9.22 | 134.08 ±12.65 | 167.65 ±8.45 | 250.47 ±9.87 |&#10;| **SortedSet** | 552.56 ±35.37 | 563.34 ±32.14 | 820.26 ±38.82 | 1438.20 ±88.70 |&#10;| **SortedDictionary** | 4342.99 ±163.66 | 3821.83 ±196.13 | 4335.23 ±262.39 | 5067.04 ±306.56 |&#10;| **ConcurrentDictionary** | 700.83 ±94.79 | 591.98 ±53.78 | 715.52 ±166.90 | 765.60 ±67.83 |&#10;| **ImmutableList** | 838.86 ±20.71 | 4567.22 ±1574.60 | 21391.03 ±1052.32 | 198214.07 ±4928.54 |&#10;| **ImmutableHashSet** | 3983.41 ±228.63 | 3660.62 ±817.27 | 3962.36 ±922.61 | 4201.21 ±862.65 |&#10;&#10;## Key Performance Insights&#10;&#10;###  Best Performers by Category&#10;&#10;#### Creation Time Champions&#10;- **Small collections (N≤100)**: Array and List (sub-microsecond performance)&#10;- **Large collections (N≥1,000)**: Array and List maintain excellent creation performance&#10;&#10;#### Lookup Time Champions&#10;- **Hash-based lookups**: HashSet and Dictionary show O(1) performance across all scales&#10;- **Sequential access**: Array and List excel for small lookup counts&#10;- **Sorted access**: SortedSet and SortedDictionary provide O(log n) performance&#10;&#10;#### Total Performance Winners&#10;- **Small workloads**: Array and List dominate&#10;- **Medium workloads**: HashSet and Dictionary take the lead&#10;- **Large workloads**: Hash-based collections maintain superiority&#10;&#10;###  Performance Patterns&#10;&#10;1. **Scalability**: Hash-based collections (HashSet, Dictionary) show excellent scalability&#10;2. **Consistency**: Array and List provide very consistent performance with low variance&#10;3. **Thread Safety Cost**: ConcurrentDictionary shows ~2-3x overhead compared to Dictionary&#10;4. **Immutability Cost**: Immutable collections show significant performance penalties, especially for large datasets&#10;5. **Sorted Structure Cost**: SortedSet and SortedDictionary have higher overhead but provide ordering guarantees&#10;&#10;### ⚠️ Performance Warnings&#10;&#10;- **ImmutableList**: Shows exponential degradation with size, unsuitable for large collections&#10;- **Large sorted collections**: SortedDictionary creation time becomes prohibitive at N=10,000&#10;- **High lookup counts**: Sequential collections (Array, List) become inefficient for many lookups&#10;&#10;---&#10;&#10;*Statistics format: Mean ±Standard Deviation (all times in microseconds)*&#10;*Outliers removed using Z-score &gt; 2.0 threshold*" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>