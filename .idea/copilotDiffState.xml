<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.gitignore">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.gitignore" />
              <option name="originalContent" value="# Build results&#10;[Dd]ebug/&#10;[Dd]ebugPublic/&#10;[Rr]elease/&#10;[Rr]eleases/&#10;x64/&#10;x86/&#10;[Ww][Ii][Nn]32/&#10;[Aa][Rr][Mm]/&#10;[Aa][Rr][Mm]64/&#10;bld/&#10;[Bb]in/&#10;[Oo]bj/&#10;[Ll]og/&#10;[Ll]ogs/&#10;&#10;# Visual Studio 2015/2017 cache/options directory&#10;.vs/&#10;# Uncomment if you have tasks that create the project's static files in wwwroot&#10;#wwwroot/&#10;&#10;# Visual Studio 2017 auto generated files&#10;Generated\ Files/&#10;&#10;# MSTest test Results&#10;[Tt]est[Rr]esult*/&#10;[Bb]uild[Ll]og.*&#10;&#10;# NUnit&#10;*.VisualState.xml&#10;TestResult.xml&#10;nunit-*.xml&#10;&#10;# Build Results of an ATL Project&#10;[Dd]ebugPS/&#10;[Rr]eleasePS/&#10;dlldata.c&#10;&#10;# Benchmark Results&#10;BenchmarkDotNet.Artifacts/&#10;&#10;# .NET Core&#10;project.lock.json&#10;project.fragment.lock.json&#10;artifacts/&#10;&#10;# StyleCop&#10;StyleCopReport.xml&#10;&#10;# Files built by Visual Studio&#10;*_i.c&#10;*_p.c&#10;*_h.h&#10;*.ilk&#10;*.meta&#10;*.obj&#10;*.iobj&#10;*.pch&#10;*.pdb&#10;*.ipdb&#10;*.pgc&#10;*.pgd&#10;*.rsp&#10;*.sbr&#10;*.tlb&#10;*.tli&#10;*.tlh&#10;*.tmp&#10;*.tmp_proj&#10;*_wpftmp.csproj&#10;*.log&#10;*.vspscc&#10;*.vssscc&#10;.builds&#10;*.pidb&#10;*.svclog&#10;*.scc&#10;&#10;# Chutzpah Test files&#10;_Chutzpah*&#10;&#10;# Visual C++ cache files&#10;ipch/&#10;*.aps&#10;*.ncb&#10;*.opendb&#10;*.opensdf&#10;*.sdf&#10;*.cachefile&#10;*.VC.db&#10;*.VC.VC.opendb&#10;&#10;# Visual Studio profiler&#10;*.psess&#10;*.vsp&#10;*.vspx&#10;*.sap&#10;&#10;# Visual Studio Trace Files&#10;*.e2e&#10;&#10;# TFS 2012 Local Workspace&#10;$tf/&#10;&#10;# Guidance Automation Toolkit&#10;*.gpState&#10;&#10;# ReSharper is a .NET coding add-in&#10;_ReSharper*/&#10;*.[Rr]e[Ss]harper&#10;*.DotSettings.user&#10;&#10;# TeamCity is a build add-in&#10;_TeamCity*&#10;&#10;# DotCover is a Code Coverage Tool&#10;*.dotCover&#10;&#10;# AxoCover is a Code Coverage Tool&#10;.axoCover/*&#10;!.axoCover/settings.json&#10;&#10;# Coverlet is a free, cross platform Code Coverage Tool&#10;coverage*.json&#10;coverage*.xml&#10;coverage*.info&#10;&#10;# Visual Studio code coverage results&#10;*.coverage&#10;*.coveragexml&#10;&#10;# NCrunch&#10;_NCrunch_*&#10;.*crunch*.local.xml&#10;nCrunchTemp_*&#10;&#10;# MightyMoose&#10;*.mm.*&#10;AutoTest.Net/&#10;&#10;# Web workbench (sass)&#10;.sass-cache/&#10;&#10;# Installshield output folder&#10;[Ee]xpress/&#10;&#10;# DocProject is a documentation generator add-in&#10;DocProject/buildhelp/&#10;DocProject/Help/*.HxT&#10;DocProject/Help/*.HxC&#10;DocProject/Help/Html2&#10;DocProject/Help/html&#10;&#10;# Click-Once directory&#10;publish/&#10;&#10;# Publish Web Output&#10;*.[Pp]ublish.xml&#10;*.azurePubxml&#10;# Note: Comment the next line if you want to checkin your web deploy settings,&#10;# but database connection strings (with potential passwords) will be unencrypted&#10;*.pubxml&#10;*.publishproj&#10;&#10;# Microsoft Azure Web App publish settings. Comment the next line if you want to&#10;# checkin your Azure Web App publish settings, but sensitive information contained&#10;# in these files may be visible to others.&#10;*.azurePubxml&#10;&#10;# NuGet Packages&#10;*.nupkg&#10;# NuGet Symbol Packages&#10;*.snupkg&#10;# The packages folder can be ignored because of Package Restore&#10;**/[Pp]ackages/*&#10;# except build/, which is used as an MSBuild target.&#10;!**/[Pp]ackages/build/&#10;# Uncomment if necessary however generally it will be regenerated when needed&#10;#!**/[Pp]ackages/repositories.config&#10;# NuGet v3's project.json files produces more ignorable files&#10;*.nuget.props&#10;*.nuget.targets&#10;&#10;# Microsoft Azure Build Output&#10;csx/&#10;*.build.csdef&#10;&#10;# Microsoft Azure Emulator&#10;ecf/&#10;rcf/&#10;&#10;# Windows Store app package directories and files&#10;AppPackages/&#10;BundleArtifacts/&#10;Package.StoreAssociation.xml&#10;_pkginfo.txt&#10;*.appx&#10;*.appxbundle&#10;*.appxupload&#10;&#10;# Visual Studio cache files&#10;# files ending in .cache can be ignored&#10;*.[Cc]ache&#10;# but keep track of directories ending in .cache&#10;!?*.[Cc]ache/&#10;&#10;# Others&#10;ClientBin/&#10;~$*&#10;*~&#10;*.dbmdl&#10;*.dbproj.schemaview&#10;*.jfm&#10;*.pfx&#10;*.publishsettings&#10;orleans.codegen.cs&#10;&#10;# Including strong name files can present a security risk&#10;# (https://github.com/github/gitignore/pull/2483#issue-259490424)&#10;#*.snk&#10;&#10;# Since there are multiple workflows, uncomment the next line to ignore bower_components&#10;# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)&#10;#bower_components/&#10;&#10;# RIA/Silverlight projects&#10;Generated_Code/&#10;&#10;# Backup &amp; report files from converting an old project file&#10;# to a newer Visual Studio version. Backup files are not needed,&#10;# because we have git ;-)&#10;_UpgradeReport_Files/&#10;Backup*/&#10;UpgradeLog*.XML&#10;UpgradeLog*.htm&#10;CConversionReport*&#10;&#10;# SQL Server files&#10;*.mdf&#10;*.ldf&#10;*.ndf&#10;&#10;# Business Intelligence projects&#10;*.rdl.data&#10;*.bim.layout&#10;*.bim_*.settings&#10;*.rptproj.rsuser&#10;*- [Bb]ackup.rdl&#10;*- [Bb]ackup ([0-9]).rdl&#10;*- [Bb]ackup ([0-9][0-9]).rdl&#10;&#10;# Microsoft Fakes&#10;FakesAssemblies/&#10;&#10;# GhostDoc plugin setting file&#10;*.GhostDoc.xml&#10;&#10;# Node.js Tools for Visual Studio&#10;.ntvs_analysis.dat&#10;node_modules/&#10;&#10;# Visual Studio 6 build log&#10;*.plg&#10;&#10;# Visual Studio 6 workspace options file&#10;*.opt&#10;&#10;# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)&#10;*.vbw&#10;&#10;# Visual Studio LightSwitch build output&#10;**/*.HTMLClient/GeneratedArtifacts&#10;**/*.DesktopClient/GeneratedArtifacts&#10;**/*.DesktopClient/ModelManifest.xml&#10;**/*.Server/GeneratedArtifacts&#10;**/*.Server/ModelManifest.xml&#10;_Pvt_Extensions&#10;&#10;# Paket dependency manager&#10;.paket/paket.exe&#10;paket-files/&#10;&#10;# FAKE - F# Make&#10;.fake/&#10;&#10;# CodeRush personal settings&#10;.cr/personal&#10;&#10;# Python Tools for Visual Studio (PTVS)&#10;__pycache__/&#10;*.pyc&#10;&#10;# Cake - Uncomment if you are using it&#10;# tools/**&#10;# !tools/packages.config&#10;&#10;# Tabs Studio&#10;*.tss&#10;&#10;# Telerik's JustMock configuration file&#10;*.jmconfig&#10;&#10;# BizTalk build output&#10;*.btp.cs&#10;*.btm.cs&#10;*.odx.cs&#10;*.xsd.cs&#10;&#10;# OpenCover UI analysis results&#10;OpenCover/&#10;&#10;# Azure Stream Analytics local run output&#10;ASALocalRun/&#10;&#10;# MSBuild Binary and Structured Log&#10;*.binlog&#10;&#10;# NVidia Nsight GPU debugger configuration file&#10;*.nvuser&#10;&#10;# MFractals&#10;*.mfractor/&#10;&#10;# Local History for Visual Studio&#10;.localhistory/&#10;&#10;# BeatPulse healthcheck temp database&#10;healthchecksdb&#10;&#10;# Backup folder for Package Reference Convert tool in Visual Studio 2017&#10;MigrationBackup/&#10;&#10;# Ionide (cross platform F# VS Code tools) working folder&#10;.ionide/&#10;&#10;# Fody - auto-generated XML schema&#10;FodyWeavers.xsd&#10;&#10;# Copilot diff state&#10;copilotDiffState.xml" />
              <option name="updatedContent" value="# Build results&#13;&#10;[Dd]ebug/&#13;&#10;[Dd]ebugPublic/&#13;&#10;[Rr]elease/&#13;&#10;[Rr]eleases/&#13;&#10;x64/&#13;&#10;x86/&#13;&#10;[Ww][Ii][Nn]32/&#13;&#10;[Aa][Rr][Mm]/&#13;&#10;[Aa][Rr][Mm]64/&#13;&#10;bld/&#13;&#10;[Bb]in/&#13;&#10;[Oo]bj/&#13;&#10;[Ll]og/&#13;&#10;[Ll]ogs/&#13;&#10;&#13;&#10;# Visual Studio 2015/2017 cache/options directory&#13;&#10;.vs/&#13;&#10;# Uncomment if you have tasks that create the project's static files in wwwroot&#13;&#10;#wwwroot/&#13;&#10;&#13;&#10;# Visual Studio 2017 auto generated files&#13;&#10;Generated\ Files/&#13;&#10;&#13;&#10;# MSTest test Results&#13;&#10;[Tt]est[Rr]esult*/&#13;&#10;[Bb]uild[Ll]og.*&#13;&#10;&#13;&#10;# NUnit&#13;&#10;*.VisualState.xml&#13;&#10;TestResult.xml&#13;&#10;nunit-*.xml&#13;&#10;&#13;&#10;# Build Results of an ATL Project&#13;&#10;[Dd]ebugPS/&#13;&#10;[Rr]eleasePS/&#13;&#10;dlldata.c&#13;&#10;&#13;&#10;# Benchmark Results&#13;&#10;BenchmarkDotNet.Artifacts/&#13;&#10;&#13;&#10;# .NET Core&#13;&#10;project.lock.json&#13;&#10;project.fragment.lock.json&#13;&#10;artifacts/&#13;&#10;&#13;&#10;# StyleCop&#13;&#10;StyleCopReport.xml&#13;&#10;&#13;&#10;# Files built by Visual Studio&#13;&#10;*_i.c&#13;&#10;*_p.c&#13;&#10;*_h.h&#13;&#10;*.ilk&#13;&#10;*.meta&#13;&#10;*.obj&#13;&#10;*.iobj&#13;&#10;*.pch&#13;&#10;*.pdb&#13;&#10;*.ipdb&#13;&#10;*.pgc&#13;&#10;*.pgd&#13;&#10;*.rsp&#13;&#10;*.sbr&#13;&#10;*.tlb&#13;&#10;*.tli&#13;&#10;*.tlh&#13;&#10;*.tmp&#13;&#10;*.tmp_proj&#13;&#10;*_wpftmp.csproj&#13;&#10;*.log&#13;&#10;*.vspscc&#13;&#10;*.vssscc&#13;&#10;.builds&#13;&#10;*.pidb&#13;&#10;*.svclog&#13;&#10;*.scc&#13;&#10;&#13;&#10;# Chutzpah Test files&#13;&#10;_Chutzpah*&#13;&#10;&#13;&#10;# Visual C++ cache files&#13;&#10;ipch/&#13;&#10;*.aps&#13;&#10;*.ncb&#13;&#10;*.opendb&#13;&#10;*.opensdf&#13;&#10;*.sdf&#13;&#10;*.cachefile&#13;&#10;*.VC.db&#13;&#10;*.VC.VC.opendb&#13;&#10;&#13;&#10;# Visual Studio profiler&#13;&#10;*.psess&#13;&#10;*.vsp&#13;&#10;*.vspx&#13;&#10;*.sap&#13;&#10;&#13;&#10;# Visual Studio Trace Files&#13;&#10;*.e2e&#13;&#10;&#13;&#10;# TFS 2012 Local Workspace&#13;&#10;$tf/&#13;&#10;&#13;&#10;# Guidance Automation Toolkit&#13;&#10;*.gpState&#13;&#10;&#13;&#10;# ReSharper is a .NET coding add-in&#13;&#10;_ReSharper*/&#13;&#10;*.[Rr]e[Ss]harper&#13;&#10;*.DotSettings.user&#13;&#10;&#13;&#10;# TeamCity is a build add-in&#13;&#10;_TeamCity*&#13;&#10;&#13;&#10;# DotCover is a Code Coverage Tool&#13;&#10;*.dotCover&#13;&#10;&#13;&#10;# AxoCover is a Code Coverage Tool&#13;&#10;.axoCover/*&#13;&#10;!.axoCover/settings.json&#13;&#10;&#13;&#10;# Coverlet is a free, cross platform Code Coverage Tool&#13;&#10;coverage*.json&#13;&#10;coverage*.xml&#13;&#10;coverage*.info&#13;&#10;&#13;&#10;# Visual Studio code coverage results&#13;&#10;*.coverage&#13;&#10;*.coveragexml&#13;&#10;&#13;&#10;# NCrunch&#13;&#10;_NCrunch_*&#13;&#10;.*crunch*.local.xml&#13;&#10;nCrunchTemp_*&#13;&#10;&#13;&#10;# MightyMoose&#13;&#10;*.mm.*&#13;&#10;AutoTest.Net/&#13;&#10;&#13;&#10;# Web workbench (sass)&#13;&#10;.sass-cache/&#13;&#10;&#13;&#10;# Installshield output folder&#13;&#10;[Ee]xpress/&#13;&#10;&#13;&#10;# DocProject is a documentation generator add-in&#13;&#10;DocProject/buildhelp/&#13;&#10;DocProject/Help/*.HxT&#13;&#10;DocProject/Help/*.HxC&#13;&#10;DocProject/Help/Html2&#13;&#10;DocProject/Help/html&#13;&#10;&#13;&#10;# Click-Once directory&#13;&#10;publish/&#13;&#10;&#13;&#10;# Publish Web Output&#13;&#10;*.[Pp]ublish.xml&#13;&#10;*.azurePubxml&#13;&#10;# Note: Comment the next line if you want to checkin your web deploy settings,&#13;&#10;# but database connection strings (with potential passwords) will be unencrypted&#13;&#10;*.pubxml&#13;&#10;*.publishproj&#13;&#10;&#13;&#10;# Microsoft Azure Web App publish settings. Comment the next line if you want to&#13;&#10;# checkin your Azure Web App publish settings, but sensitive information contained&#13;&#10;# in these files may be visible to others.&#13;&#10;*.azurePubxml&#13;&#10;&#13;&#10;# NuGet Packages&#13;&#10;*.nupkg&#13;&#10;# NuGet Symbol Packages&#13;&#10;*.snupkg&#13;&#10;# The packages folder can be ignored because of Package Restore&#13;&#10;**/[Pp]ackages/*&#13;&#10;# except build/, which is used as an MSBuild target.&#13;&#10;!**/[Pp]ackages/build/&#13;&#10;# Uncomment if necessary however generally it will be regenerated when needed&#13;&#10;#!**/[Pp]ackages/repositories.config&#13;&#10;# NuGet v3's project.json files produces more ignorable files&#13;&#10;*.nuget.props&#13;&#10;*.nuget.targets&#13;&#10;&#13;&#10;# Microsoft Azure Build Output&#13;&#10;csx/&#13;&#10;*.build.csdef&#13;&#10;&#13;&#10;# Microsoft Azure Emulator&#13;&#10;ecf/&#13;&#10;rcf/&#13;&#10;&#13;&#10;# Windows Store app package directories and files&#13;&#10;AppPackages/&#13;&#10;BundleArtifacts/&#13;&#10;Package.StoreAssociation.xml&#13;&#10;_pkginfo.txt&#13;&#10;*.appx&#13;&#10;*.appxbundle&#13;&#10;*.appxupload&#13;&#10;&#13;&#10;# Visual Studio cache files&#13;&#10;# files ending in .cache can be ignored&#13;&#10;*.[Cc]ache&#13;&#10;# but keep track of directories ending in .cache&#13;&#10;!?*.[Cc]ache/&#13;&#10;&#13;&#10;# Others&#13;&#10;ClientBin/&#13;&#10;~$*&#13;&#10;*~&#13;&#10;*.dbmdl&#13;&#10;*.dbproj.schemaview&#13;&#10;*.jfm&#13;&#10;*.pfx&#13;&#10;*.publishsettings&#13;&#10;orleans.codegen.cs&#13;&#10;&#13;&#10;# Including strong name files can present a security risk&#13;&#10;# (https://github.com/github/gitignore/pull/2483#issue-259490424)&#13;&#10;#*.snk&#13;&#10;&#13;&#10;# Since there are multiple workflows, uncomment the next line to ignore bower_components&#13;&#10;# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)&#13;&#10;#bower_components/&#13;&#10;&#13;&#10;# RIA/Silverlight projects&#13;&#10;Generated_Code/&#13;&#10;&#13;&#10;# Backup &amp; report files from converting an old project file&#13;&#10;# to a newer Visual Studio version. Backup files are not needed,&#13;&#10;# because we have git ;-)&#13;&#10;_UpgradeReport_Files/&#13;&#10;Backup*/&#13;&#10;UpgradeLog*.XML&#13;&#10;UpgradeLog*.htm&#13;&#10;CConversionReport*&#13;&#10;&#13;&#10;# SQL Server files&#13;&#10;*.mdf&#13;&#10;*.ldf&#13;&#10;*.ndf&#13;&#10;&#13;&#10;# Business Intelligence projects&#13;&#10;*.rdl.data&#13;&#10;*.bim.layout&#13;&#10;*.bim_*.settings&#13;&#10;*.rptproj.rsuser&#13;&#10;*- [Bb]ackup.rdl&#13;&#10;*- [Bb]ackup ([0-9]).rdl&#13;&#10;*- [Bb]ackup ([0-9][0-9]).rdl&#13;&#10;&#13;&#10;# Microsoft Fakes&#13;&#10;FakesAssemblies/&#13;&#10;&#13;&#10;# GhostDoc plugin setting file&#13;&#10;*.GhostDoc.xml&#13;&#10;&#13;&#10;# Node.js Tools for Visual Studio&#13;&#10;.ntvs_analysis.dat&#13;&#10;node_modules/&#13;&#10;&#13;&#10;# Visual Studio 6 build log&#13;&#10;*.plg&#13;&#10;&#13;&#10;# Visual Studio 6 workspace options file&#13;&#10;*.opt&#13;&#10;&#13;&#10;# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)&#13;&#10;*.vbw&#13;&#10;&#13;&#10;# Visual Studio LightSwitch build output&#13;&#10;**/*.HTMLClient/GeneratedArtifacts&#13;&#10;**/*.DesktopClient/GeneratedArtifacts&#13;&#10;**/*.DesktopClient/ModelManifest.xml&#13;&#10;**/*.Server/GeneratedArtifacts&#13;&#10;**/*.Server/ModelManifest.xml&#13;&#10;_Pvt_Extensions&#13;&#10;&#13;&#10;# Paket dependency manager&#13;&#10;.paket/paket.exe&#13;&#10;paket-files/&#13;&#10;&#13;&#10;# FAKE - F# Make&#13;&#10;.fake/&#13;&#10;&#13;&#10;# CodeRush personal settings&#13;&#10;.cr/personal&#13;&#10;&#13;&#10;# Python Tools for Visual Studio (PTVS)&#13;&#10;__pycache__/&#13;&#10;*.pyc&#13;&#10;&#13;&#10;# Cake - Uncomment if you are using it&#13;&#10;# tools/**&#13;&#10;# !tools/packages.config&#13;&#10;&#13;&#10;# Tabs Studio&#13;&#10;*.tss&#13;&#10;&#13;&#10;# Telerik's JustMock configuration file&#13;&#10;*.jmconfig&#13;&#10;&#13;&#10;# BizTalk build output&#13;&#10;*.btp.cs&#13;&#10;*.btm.cs&#13;&#10;*.odx.cs&#13;&#10;*.xsd.cs&#13;&#10;&#13;&#10;# OpenCover UI analysis results&#13;&#10;OpenCover/&#13;&#10;&#13;&#10;# Azure Stream Analytics local run output&#13;&#10;ASALocalRun/&#13;&#10;&#13;&#10;# MSBuild Binary and Structured Log&#13;&#10;*.binlog&#13;&#10;&#13;&#10;# NVidia Nsight GPU debugger configuration file&#13;&#10;*.nvuser&#13;&#10;&#13;&#10;# MFractals&#13;&#10;*.mfractor/&#13;&#10;&#13;&#10;# Local History for Visual Studio&#13;&#10;.localhistory/&#13;&#10;&#13;&#10;# BeatPulse healthcheck temp database&#13;&#10;healthchecksdb&#13;&#10;&#13;&#10;# Backup folder for Package Reference Convert tool in Visual Studio 2017&#13;&#10;MigrationBackup/&#13;&#10;&#13;&#10;# Ionide (cross platform F# VS Code tools) working folder&#13;&#10;.ionide/&#13;&#10;&#13;&#10;# Fody - auto-generated XML schema&#13;&#10;FodyWeavers.xsd&#13;&#10;&#13;&#10;# Copilot diff state&#13;&#10;copilotDiffState.xml" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ArrayOperationBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ArrayOperationBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class ArrayOperationBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntArray_IndexOf_Lookup()&#10;        {&#10;            var collection = intSourceData.ToArray();&#10;            foreach (var item in intLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringArray_IndexOf_Lookup()&#10;        {&#10;            var collection = stringSourceData.ToArray();&#10;            foreach (var item in stringLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntArray_BinarySearch_Lookup()&#10;        {&#10;            var collection = intSourceData.ToArray();&#10;            Array.Sort(collection);&#10;            foreach (var item in intLookupItems)&#10;                _ = Array.BinarySearch(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringArray_BinarySearch_Lookup()&#10;        {&#10;            var collection = stringSourceData.ToArray();&#10;            Array.Sort(collection);&#10;            foreach (var item in stringLookupItems)&#10;                _ = Array.BinarySearch(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntArray_Contains_Lookup()&#10;        {&#10;            var collection = intSourceData.ToArray();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringArray_Contains_Lookup()&#10;        {&#10;            var collection = stringSourceData.ToArray();&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ConcurrentCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ConcurrentCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class ConcurrentCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntConcurrentDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentDictionary&lt;int, bool&gt;(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringConcurrentDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentDictionary&lt;string, bool&gt;(stringSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntConcurrentBag_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentBag&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringConcurrentBag_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentBag&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/CustomReferenceTypeBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/CustomReferenceTypeBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    // Custom reference type for testing&#10;    public class Customer : IEquatable&lt;Customer&gt;, IComparable&lt;Customer&gt;&#10;    {&#10;        public string Id { get; }&#10;        public string Name { get; }&#10;        &#10;        public Customer(string id, string name)&#10;        {&#10;            Id = id;&#10;            Name = name;&#10;        }&#10;        &#10;        public bool Equals(Customer? other) =&gt; other != null &amp;&amp; Id == other.Id;&#10;        public override bool Equals(object? obj) =&gt; Equals(obj as Customer);&#10;        public override int GetHashCode() =&gt; Id?.GetHashCode() ?? 0;&#10;        &#10;        public int CompareTo(Customer? other)&#10;        {&#10;            if (other == null) return 1;&#10;            return string.Compare(Id, other.Id, StringComparison.Ordinal);&#10;        }&#10;    }&#10;&#10;    [MemoryDiagnoser]&#10;    public class CustomReferenceTypeBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private Customer[] customerSourceData = null!;&#10;        private Customer[] customerLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            customerSourceData = Enumerable.Range(1, N).Select(i =&gt; new Customer($&quot;CUST_{random.Next()}&quot;, $&quot;Customer {i}&quot;)).ToArray();&#10;            customerLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; new Customer($&quot;CUST_{random.Next()}&quot;, $&quot;Customer {i}&quot;)).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;Customer&gt;(customerSourceData);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;Customer&gt;(customerSourceData);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;Customer&gt;(customerSourceData);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerDictionary_CreationAndLookup()&#10;        {&#10;            var collection = customerSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/CustomValueTypeBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/CustomValueTypeBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    // Custom value type for testing&#10;    public struct ProductId : IEquatable&lt;ProductId&gt;, IComparable&lt;ProductId&gt;&#10;    {&#10;        public int Value { get; }&#10;        &#10;        public ProductId(int value) =&gt; Value = value;&#10;        &#10;        public bool Equals(ProductId other) =&gt; Value == other.Value;&#10;        public override bool Equals(object? obj) =&gt; obj is ProductId other &amp;&amp; Equals(other);&#10;        public override int GetHashCode() =&gt; Value.GetHashCode();&#10;        public static implicit operator ProductId(int value) =&gt; new(value);&#10;        &#10;        public int CompareTo(ProductId other) =&gt; Value.CompareTo(other.Value);&#10;    }&#10;&#10;    [MemoryDiagnoser]&#10;    public class CustomValueTypeBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private ProductId[] productIdSourceData = null!;&#10;        private ProductId[] productIdLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            productIdSourceData = Enumerable.Range(1, N).Select(i =&gt; new ProductId(random.Next())).Distinct().Take(N).ToArray();&#10;            productIdLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; new ProductId(random.Next())).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;ProductId&gt;(productIdSourceData);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;ProductId&gt;(productIdSourceData);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;ProductId&gt;(productIdSourceData);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdDictionary_CreationAndLookup()&#10;        {&#10;            var collection = productIdSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/GuidCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/GuidCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class GuidCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private Guid[] guidSourceData = null!;&#10;        private Guid[] guidLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            guidSourceData = Enumerable.Range(1, N).Select(i =&gt; Guid.NewGuid()).ToArray();&#10;            guidLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; Guid.NewGuid()).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;Guid&gt;(guidSourceData);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;Guid&gt;(guidSourceData);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;Guid&gt;(guidSourceData);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidDictionary_CreationAndLookup()&#10;        {&#10;            var collection = guidSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidSortedDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new SortedDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ImmutableCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ImmutableCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class ImmutableCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableList_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableList.CreateRange(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableHashSet_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableHashSet.CreateRange(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableSortedSet.CreateRange(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringImmutableList_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableList.CreateRange(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringImmutableHashSet_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableHashSet.CreateRange(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableDictionary_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableDictionary.CreateRange(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/IntegerCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/IntegerCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class IntegerCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntDictionary_CreationAndLookup()&#10;        {&#10;            var collection = intSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntSortedDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new SortedDictionary&lt;int, bool&gt;(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ParallelBenchmarkRunner.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ParallelBenchmarkRunner.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Diagnostics;&#10;using System.Threading.Tasks;&#10;using BenchmarkDotNet.Running;&#10;using BenchmarkDotNet.Configs;&#10;using BenchmarkDotNet.Jobs;&#10;using BenchmarkDotNet.Toolchains.CsProj;&#10;using BenchmarkDotNet.Toolchains.DotNetCli;&#10;&#10;namespace Benchmarks&#10;{&#10;    public class ParallelBenchmarkRunner&#10;    {&#10;        private readonly int _parallelInstances;&#10;        private readonly ManualConfig _releaseConfig;&#10;&#10;        public ParallelBenchmarkRunner(int parallelInstances = 8)&#10;        {&#10;            _parallelInstances = parallelInstances;&#10;            &#10;            // Create optimized release configuration&#10;            _releaseConfig = ManualConfig.Create(DefaultConfig.Instance)&#10;                .WithOptions(ConfigOptions.DisableOptimizationsValidator)&#10;                .AddJob(Job.Default&#10;                    .WithToolchain(CsProjCoreToolchain.NetCoreApp90)&#10;                    .WithId(&quot;ReleaseJob&quot;))&#10;                .WithOption(ConfigOptions.JoinSummary, true);&#10;        }&#10;&#10;        public async Task RunBenchmarksInParallel()&#10;        {&#10;            Console.WriteLine($&quot;Starting parallel benchmark execution with {_parallelInstances} instances...&quot;);&#10;            Console.WriteLine($&quot;CPU Core Count: {Environment.ProcessorCount}&quot;);&#10;            Console.WriteLine(new string('=', 80));&#10;&#10;            var benchmarkTasks = new List&lt;Task&gt;();&#10;            var results = new ConcurrentBag&lt;BenchmarkResult&gt;();&#10;            var stopwatch = Stopwatch.StartNew();&#10;&#10;            // Define different benchmark scenarios to run in parallel&#10;            var benchmarkScenarios = new List&lt;BenchmarkScenario&gt;&#10;            {&#10;                new(&quot;IntegerCollections&quot;, () =&gt; RunBenchmarkSafely&lt;IntegerCollectionBenchmarks&gt;()),&#10;                new(&quot;StringCollections&quot;, () =&gt; RunBenchmarkSafely&lt;StringCollectionBenchmarks&gt;()),&#10;                new(&quot;GuidCollections&quot;, () =&gt; RunBenchmarkSafely&lt;GuidCollectionBenchmarks&gt;()),&#10;                new(&quot;CustomValueTypes&quot;, () =&gt; RunBenchmarkSafely&lt;CustomValueTypeBenchmarks&gt;()),&#10;                new(&quot;CustomReferenceTypes&quot;, () =&gt; RunBenchmarkSafely&lt;CustomReferenceTypeBenchmarks&gt;()),&#10;                new(&quot;ImmutableCollections&quot;, () =&gt; RunBenchmarkSafely&lt;ImmutableCollectionBenchmarks&gt;()),&#10;                new(&quot;ConcurrentCollections&quot;, () =&gt; RunBenchmarkSafely&lt;ConcurrentCollectionBenchmarks&gt;()),&#10;                new(&quot;ArrayOperations&quot;, () =&gt; RunBenchmarkSafely&lt;ArrayOperationBenchmarks&gt;())&#10;            };&#10;&#10;            // Take only the number of scenarios we want to run in parallel&#10;            var scenariosToRun = benchmarkScenarios.Take(_parallelInstances);&#10;&#10;            foreach (var scenario in scenariosToRun)&#10;            {&#10;                var task = Task.Run(async () =&gt;&#10;                {&#10;                    var taskStopwatch = Stopwatch.StartNew();&#10;                    Console.WriteLine($&quot;[{DateTime.Now:HH:mm:ss}] Starting {scenario.Name}...&quot;);&#10;                    &#10;                    try&#10;                    {&#10;                        var result = await scenario.ExecuteAsync();&#10;                        taskStopwatch.Stop();&#10;                        &#10;                        var benchmarkResult = new BenchmarkResult&#10;                        {&#10;                            ScenarioName = scenario.Name,&#10;                            Success = result != null,&#10;                            Duration = taskStopwatch.Elapsed,&#10;                            ErrorMessage = result == null ? &quot;Benchmark returned null&quot; : null&#10;                        };&#10;                        &#10;                        results.Add(benchmarkResult);&#10;                        Console.WriteLine($&quot;[{DateTime.Now:HH:mm:ss}] Completed {scenario.Name} in {taskStopwatch.Elapsed:mm\\:ss}&quot;);&#10;                    }&#10;                    catch (Exception ex)&#10;                    {&#10;                        taskStopwatch.Stop();&#10;                        var benchmarkResult = new BenchmarkResult&#10;                        {&#10;                            ScenarioName = scenario.Name,&#10;                            Success = false,&#10;                            Duration = taskStopwatch.Elapsed,&#10;                            ErrorMessage = ex.Message&#10;                        };&#10;                        &#10;                        results.Add(benchmarkResult);&#10;                        Console.WriteLine($&quot;[{DateTime.Now:HH:mm:ss}] Failed {scenario.Name}: {ex.Message}&quot;);&#10;                    }&#10;                });&#10;                &#10;                benchmarkTasks.Add(task);&#10;            }&#10;&#10;            // Wait for all benchmarks to complete&#10;            await Task.WhenAll(benchmarkTasks);&#10;            stopwatch.Stop();&#10;&#10;            // Print summary&#10;            Console.WriteLine(&quot;\n&quot; + new string('=', 80));&#10;            Console.WriteLine(&quot;PARALLEL BENCHMARK EXECUTION SUMMARY&quot;);&#10;            Console.WriteLine(new string('=', 80));&#10;            Console.WriteLine($&quot;Total Execution Time: {stopwatch.Elapsed:mm\\:ss}&quot;);&#10;            Console.WriteLine($&quot;Parallel Instances: {_parallelInstances}&quot;);&#10;            Console.WriteLine();&#10;&#10;            foreach (var result in results)&#10;            {&#10;                var status = result.Success ? &quot;✓ SUCCESS&quot; : &quot;✗ FAILED&quot;;&#10;                Console.WriteLine($&quot;{status,-12} {result.ScenarioName,-25} Duration: {result.Duration:mm\\:ss}&quot;);&#10;                if (!result.Success &amp;&amp; !string.IsNullOrEmpty(result.ErrorMessage))&#10;                {&#10;                    Console.WriteLine($&quot;             Error: {result.ErrorMessage}&quot;);&#10;                }&#10;            }&#10;&#10;            var successCount = results.Count(r =&gt; r.Success);&#10;            var failCount = results.Count(r =&gt; !r.Success);&#10;            &#10;            Console.WriteLine();&#10;            Console.WriteLine($&quot;Results: {successCount} successful, {failCount} failed&quot;);&#10;            Console.WriteLine(new string('=', 80));&#10;        }&#10;&#10;        private async Task&lt;object&gt; RunBenchmarkSafely&lt;T&gt;() where T : class&#10;        {&#10;            return await Task.Run(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    return BenchmarkRunner.Run&lt;T&gt;(_releaseConfig);&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    Console.WriteLine($&quot;Error running benchmark {typeof(T).Name}: {ex.Message}&quot;);&#10;                    throw;&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    public record BenchmarkScenario(string Name, Func&lt;Task&lt;object&gt;&gt; ExecuteAsync);&#10;&#10;    public class BenchmarkResult&#10;    {&#10;        public string ScenarioName { get; set; } = string.Empty;&#10;        public bool Success { get; set; }&#10;        public TimeSpan Duration { get; set; }&#10;        public string? ErrorMessage { get; set; }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ParallelizedGuidBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ParallelizedGuidBenchmarks.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.Diagnostics;&#10;using System.IO;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using BenchmarkDotNet.Attributes;&#10;using BenchmarkDotNet.Jobs;&#10;using BenchmarkDotNet.Engines;&#10;&#10;namespace Benchmarks&#10;{&#10;    [SimpleJob(RunStrategy.Monitoring, warmupCount: 3, iterationCount: 30)]&#10;    [MemoryDiagnoser]&#10;    public class ParallelizedGuidBenchmarks&#10;    {&#10;        [Params(10, 100, 1000, 10000)]&#10;        public int N { get; set; }&#10;&#10;        [Params(10, 100, 1000, 10000)]&#10;        public int LookupCount { get; set; }&#10;&#10;        private Guid[] guidSourceData = null!;&#10;        private Guid[] guidLookupItems = null!;&#10;        private static readonly object _fileLock = new object();&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            // Generate N unique GUIDs for the collection&#10;            guidSourceData = new Guid[N];&#10;            for (int i = 0; i &lt; N; i++)&#10;            {&#10;                guidSourceData[i] = Guid.NewGuid();&#10;            }&#10;&#10;            // Generate lookup items (mix of existing and non-existing GUIDs)&#10;            guidLookupItems = new Guid[LookupCount];&#10;            var random = new Random(42); // Fixed seed for reproducibility&#10;&#10;            for (int i = 0; i &lt; LookupCount; i++)&#10;            {&#10;                if (i &lt; N &amp;&amp; random.NextDouble() &lt; 0.7) // 70% chance to use existing GUID&#10;                {&#10;                    guidLookupItems[i] = guidSourceData[random.Next(N)];&#10;                }&#10;                else // 30% chance to use non-existing GUID&#10;                {&#10;                    guidLookupItems[i] = Guid.NewGuid();&#10;                }&#10;            }&#10;        }&#10;&#10;        private void LogDetailedResults(string collectionType, int n, int lookupCount, TimeSpan creationTime, TimeSpan lookupTime, TimeSpan totalTime)&#10;        {&#10;            // Use a hardcoded absolute path to ensure we can find it&#10;            var logPath = @&quot;C:\Users\Gustavo\Documents\Projetos\Estudos_Csharp\CSharpStudies\Topic6\Benchmarks\BenchmarkDotNet.Artifacts\detailed_results_guid.txt&quot;;&#10;            &#10;            // Ensure directory exists&#10;            Directory.CreateDirectory(Path.GetDirectoryName(logPath));&#10;            &#10;            lock (_fileLock)&#10;            {&#10;                try&#10;                {&#10;                    // Check if we need to write header BEFORE opening the file&#10;                    bool needsHeader = !File.Exists(logPath) || new FileInfo(logPath).Length == 0;&#10;                    &#10;                    using var writer = new StreamWriter(logPath, true);&#10;                    if (needsHeader)&#10;                    {&#10;                        // Write header if file doesn't exist or is empty&#10;                        writer.WriteLine(&quot;CollectionType,N,LookupCount,CreationTime_μs,LookupTime_μs,TotalTime_μs&quot;);&#10;                    }&#10;                    writer.WriteLine($&quot;{collectionType},{n},{lookupCount},{creationTime.TotalMicroseconds:F2},{lookupTime.TotalMicroseconds:F2},{totalTime.TotalMicroseconds:F2}&quot;);&#10;                    &#10;                    // Force write to disk&#10;                    writer.Flush();&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    // If there's an issue, write to a backup location we can debug&#10;                    var backupPath = @&quot;C:\temp\benchmark_debug_guid.txt&quot;;&#10;                    Directory.CreateDirectory(Path.GetDirectoryName(backupPath));&#10;                    File.AppendAllText(backupPath, $&quot;ERROR: {ex.Message}\n&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidArray_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = guidSourceData.ToArray();&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            LogDetailedResults(&quot;Array&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidList_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new List&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            LogDetailedResults(&quot;List&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidHashSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new HashSet&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            LogDetailedResults(&quot;HashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidSortedSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedSet&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            LogDetailedResults(&quot;SortedSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = guidSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            LogDetailedResults(&quot;Dictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidSortedDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            LogDetailedResults(&quot;SortedDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidConcurrentDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new ConcurrentDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            LogDetailedResults(&quot;ConcurrentDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidImmutableList_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableList.CreateRange(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            LogDetailedResults(&quot;ImmutableList&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidImmutableHashSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableHashSet.CreateRange(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            LogDetailedResults(&quot;ImmutableHashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.Diagnostics;&#10;using System.IO;&#10;using System.Linq;&#10;using System.Threading.Tasks;&#10;using BenchmarkDotNet.Attributes;&#10;using BenchmarkDotNet.Jobs;&#10;using BenchmarkDotNet.Engines;&#10;&#10;namespace Benchmarks&#10;{&#10;    [SimpleJob(RunStrategy.Monitoring, warmupCount: 5, iterationCount: 50)]&#10;    [MemoryDiagnoser]&#10;    [HardwareCounters(HardwareCounter.BranchMispredictions, HardwareCounter.CacheMisses)]&#10;    public class ParallelizedGuidBenchmarks&#10;    {&#10;        [Params(10, 100, 1000, 10000)]&#10;        public int N { get; set; }&#10;&#10;        [Params(10, 100, 1000, 10000)]&#10;        public int LookupCount { get; set; }&#10;&#10;        private Guid[] guidSourceData = null!;&#10;        private Guid[] guidLookupItems = null!;&#10;        private static readonly object _fileLock = new object();&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            // Generate N unique GUIDs for the collection&#10;            guidSourceData = new Guid[N];&#10;            for (int i = 0; i &lt; N; i++)&#10;            {&#10;                guidSourceData[i] = Guid.NewGuid();&#10;            }&#10;&#10;            // Generate lookup items (mix of existing and non-existing GUIDs)&#10;            guidLookupItems = new Guid[LookupCount];&#10;            var random = new Random(42); // Fixed seed for reproducibility&#10;&#10;            for (int i = 0; i &lt; LookupCount; i++)&#10;            {&#10;                if (i &lt; N &amp;&amp; random.NextDouble() &lt; 0.7) // 70% chance to use existing GUID&#10;                {&#10;                    guidLookupItems[i] = guidSourceData[random.Next(N)];&#10;                }&#10;                else // 30% chance to use non-existing GUID&#10;                {&#10;                    guidLookupItems[i] = Guid.NewGuid();&#10;                }&#10;            }&#10;        }&#10;&#10;        [IterationCleanup]&#10;        public void IterationCleanup()&#10;        {&#10;            // Force garbage collection between iterations to prevent memory pressure interference&#10;            GC.Collect();&#10;            GC.WaitForPendingFinalizers();&#10;            GC.Collect();&#10;        }&#10;&#10;        private void LogDetailedResults(string collectionType, int n, int lookupCount, TimeSpan creationTime, TimeSpan lookupTime, TimeSpan totalTime)&#10;        {&#10;            // Use a hardcoded absolute path to ensure we can find it&#10;            var logPath = @&quot;C:\Users\Gustavo\Documents\Projetos\Estudos_Csharp\CSharpStudies\Topic6\Benchmarks\BenchmarkDotNet.Artifacts\detailed_results_guid.txt&quot;;&#10;            &#10;            // Ensure directory exists&#10;            Directory.CreateDirectory(Path.GetDirectoryName(logPath));&#10;            &#10;            lock (_fileLock)&#10;            {&#10;                try&#10;                {&#10;                    // Check if we need to write header BEFORE opening the file&#10;                    bool needsHeader = !File.Exists(logPath) || new FileInfo(logPath).Length == 0;&#10;                    &#10;                    using var writer = new StreamWriter(logPath, true);&#10;                    if (needsHeader)&#10;                    {&#10;                        // Write header if file doesn't exist or is empty&#10;                        writer.WriteLine(&quot;CollectionType,N,LookupCount,CreationTime_μs,LookupTime_μs,TotalTime_μs&quot;);&#10;                    }&#10;                    writer.WriteLine($&quot;{collectionType},{n},{lookupCount},{creationTime.TotalMicroseconds:F2},{lookupTime.TotalMicroseconds:F2},{totalTime.TotalMicroseconds:F2}&quot;);&#10;                    &#10;                    // Force write to disk&#10;                    writer.Flush();&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    // If there's an issue, write to a backup location we can debug&#10;                    var backupPath = @&quot;C:\temp\benchmark_debug_guid.txt&quot;;&#10;                    Directory.CreateDirectory(Path.GetDirectoryName(backupPath));&#10;                    File.AppendAllText(backupPath, $&quot;ERROR: {ex.Message}\n&quot;);&#10;                }&#10;            }&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidArray_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = guidSourceData.ToArray();&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Array&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidList_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new List&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;List&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidHashSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new HashSet&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;HashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidSortedSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedSet&lt;Guid&gt;(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = guidSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;Dictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidSortedDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new SortedDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;SortedDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidConcurrentDictionary_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = new ConcurrentDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ConcurrentDictionary&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidImmutableList_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableList.CreateRange(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableList&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;&#10;        [Benchmark]&#10;        public double GuidImmutableHashSet_ParallelParams()&#10;        {&#10;            var totalSw = Stopwatch.StartNew();&#10;            &#10;            var creationSw = Stopwatch.StartNew();&#10;            var collection = ImmutableHashSet.CreateRange(guidSourceData);&#10;            creationSw.Stop();&#10;            &#10;            var lookupSw = Stopwatch.StartNew();&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;            lookupSw.Stop();&#10;            &#10;            totalSw.Stop();&#10;            &#10;            // Clear reference to help GC&#10;            collection = null;&#10;            &#10;            LogDetailedResults(&quot;ImmutableHashSet&quot;, N, LookupCount, creationSw.Elapsed, lookupSw.Elapsed, totalSw.Elapsed);&#10;            return totalSw.Elapsed.TotalMicroseconds;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/StringCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/StringCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class StringCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringDictionary_CreationAndLookup()&#10;        {&#10;            var collection = stringSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringSortedDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new SortedDictionary&lt;string, bool&gt;(stringSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Readme6_Benchmark_Guid.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Readme6_Benchmark_Guid.md" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="# C# Collection Performance Benchmarks - GUID Data&#10;&#10;This document contains comprehensive performance benchmark results for various C# collection types using **GUID data**. The benchmarks were conducted using BenchmarkDotNet with multiple scenarios testing creation time, lookup time, and total time performance.&#10;&#10;## Test Scenarios&#10;&#10;- **Collection Types**: Array, List, HashSet, SortedSet, Dictionary, SortedDictionary, ConcurrentDictionary, ImmutableList, ImmutableHashSet&#10;- **Collection Sizes (N)**: 10, 100, 1,000, 10,000 elements&#10;- **Lookup Counts**: 10, 100, 1,000, 10,000 lookups per test&#10;- **Data Type**: System.Guid (16-byte structure)&#10;- **Sample Size**: 34 runs per scenario with outlier detection (Z-score &gt; 2.0)&#10;&#10;## Performance Summary by Collection Size&#10;&#10;### Small Collections (N=10)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.097 ±2.600 | 0.906 ±1.570 | 9.679 ±49.423 | 0.876 ±1.297 |&#10;| **List** | 1.127 ±2.159 | 1.039 ±1.560 | 1.453 ±3.740 | 0.985 ±1.416 |&#10;| **HashSet** | 2.136 ±2.266 | 2.009 ±2.200 | 2.206 ±2.734 | 2.133 ±1.891 |&#10;| **Dictionary** | 2.403 ±1.651 | 1.930 ±1.188 | 2.484 ±1.667 | 2.509 ±1.693 |&#10;| **SortedSet** | 3.518 ±1.718 | 3.358 ±1.547 | 3.312 ±1.491 | 3.527 ±1.907 |&#10;| **SortedDictionary** | 6.503 ±2.116 | 6.282 ±2.674 | 6.653 ±2.393 | 7.427 ±6.000 |&#10;| **ConcurrentDictionary** | 5.112 ±2.364 | 4.991 ±2.391 | 5.285 ±2.273 | 7.097 ±2.562 |&#10;| **ImmutableList** | 1.564 ±0.324 | 1.618 ±0.511 | 1.681 ±0.441 | 1.761 ±0.361 |&#10;| **ImmutableHashSet** | 4.930 ±2.261 | 5.215 ±2.429 | 5.916 ±3.488 | 5.764 ±2.416 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 0.515 ±0.162 | 1.618 ±0.140 | 20.667 ±17.124 | 100.136 ±3.294 |&#10;| **List** | 0.603 ±0.217 | 1.767 ±0.122 | 17.956 ±2.301 | 102.339 ±9.263 |&#10;| **HashSet** | 0.794 ±0.120 | 3.042 ±0.218 | 36.297 ±5.619 | 232.655 ±25.106 |&#10;| **Dictionary** | 0.791 ±0.245 | 3.370 ±0.410 | 43.950 ±10.034 | 233.985 ±32.116 |&#10;| **SortedSet** | 1.312 ±0.114 | 10.315 ±1.106 | 107.559 ±9.521 | 273.118 ±13.048 |&#10;| **SortedDictionary** | 1.448 ±0.137 | 15.879 ±4.655 | 121.469 ±15.976 | 365.952 ±19.721 |&#10;| **ConcurrentDictionary** | 0.630 ±0.064 | 2.597 ±0.126 | 64.545 ±189.899 | 138.497 ±19.543 |&#10;| **ImmutableList** | 0.767 ±0.183 | 6.852 ±0.194 | 80.047 ±2.537 | 646.509 ±13.673 |&#10;| **ImmutableHashSet** | 1.639 ±0.137 | 6.427 ±0.350 | 68.619 ±5.770 | 203.897 ±10.224 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.700 ±2.727 | 2.661 ±1.627 | 30.479 ±66.153 | 101.148 ±3.909 |&#10;| **List** | 1.824 ±2.296 | 2.888 ±1.664 | 19.544 ±4.484 | 103.442 ±9.202 |&#10;| **HashSet** | 3.055 ±2.367 | 5.124 ±2.295 | 38.622 ±6.053 | 234.873 ±26.591 |&#10;| **Dictionary** | 3.294 ±1.848 | 5.379 ±1.368 | 46.553 ±9.824 | 236.630 ±33.185 |&#10;| **SortedSet** | 4.927 ±1.760 | 13.776 ±1.874 | 110.972 ±9.014 | 276.748 ±13.963 |&#10;| **SortedDictionary** | 8.048 ±2.205 | 22.258 ±6.960 | 128.216 ±15.980 | 373.488 ±20.901 |&#10;| **ConcurrentDictionary** | 5.839 ±2.403 | 7.700 ±2.529 | 69.958 ±189.805 | 145.691 ±21.405 |&#10;| **ImmutableList** | 2.445 ±0.498 | 8.573 ±0.648 | 81.819 ±2.485 | 648.385 ±13.695 |&#10;| **ImmutableHashSet** | 6.697 ±2.349 | 11.752 ±2.451 | 74.656 ±5.816 | 209.770 ±11.535 |&#10;&#10;### Medium Collections (N=100)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 1.064 ±1.860 | 1.188 ±3.041 | 8.370 ±42.407 | 1.182 ±1.593 |&#10;| **List** | 1.145 ±2.139 | 2.355 ±7.278 | 1.237 ±2.630 | 1.248 ±1.533 |&#10;| **HashSet** | 5.045 ±2.490 | 4.312 ±1.651 | 5.572 ±3.480 | 4.888 ±2.308 |&#10;| **Dictionary** | 7.455 ±2.718 | 7.061 ±1.072 | 7.191 ±1.382 | 7.348 ±2.143 |&#10;| **SortedSet** | 17.103 ±3.259 | 19.127 ±3.560 | 21.934 ±3.574 | 18.276 ±2.673 |&#10;| **SortedDictionary** | 39.312 ±5.897 | 44.170 ±4.891 | 44.497 ±6.432 | 40.267 ±7.537 |&#10;| **ConcurrentDictionary** | 25.558 ±5.315 | 22.170 ±5.125 | 26.103 ±4.306 | 27.818 ±6.335 |&#10;| **ImmutableList** | 10.252 ±4.130 | 9.073 ±3.714 | 9.828 ±3.922 | 13.256 ±6.835 |&#10;| **ImmutableHashSet** | 36.630 ±3.828 | 36.336 ±3.973 | 37.856 ±5.554 | 39.164 ±6.832 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 0.833 ±0.145 | 6.015 ±3.597 | 67.976 ±14.669 | 673.397 ±13.880 |&#10;| **List** | 0.800 ±0.222 | 5.418 ±0.642 | 68.044 ±3.371 | 676.658 ±8.399 |&#10;| **HashSet** | 0.815 ±0.177 | 3.670 ±0.598 | 42.419 ±6.732 | 229.733 ±31.454 |&#10;| **Dictionary** | 0.891 ±0.095 | 4.424 ±0.123 | 44.737 ±8.315 | 262.558 ±29.738 |&#10;| **SortedSet** | 1.539 ±0.075 | 15.967 ±1.266 | 173.925 ±24.131 | 520.400 ±20.583 |&#10;| **SortedDictionary** | 1.958 ±0.192 | 21.521 ±3.559 | 217.059 ±9.568 | 662.642 ±15.592 |&#10;| **ConcurrentDictionary** | 0.997 ±2.192 | 3.321 ±0.464 | 69.864 ±201.956 | 187.421 ±25.181 |&#10;| **ImmutableList** | 3.500 ±0.256 | 38.852 ±2.144 | 598.666 ±15.401 | 6368.153 ±306.466 |&#10;| **ImmutableHashSet** | 2.173 ±0.123 | 16.761 ±0.632 | 107.475 ±10.807 | 365.258 ±10.248 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 2.015 ±2.003 | 7.309 ±4.765 | 76.452 ±56.991 | 674.709 ±13.872 |&#10;| **List** | 2.064 ±2.329 | 7.891 ±7.281 | 69.409 ±4.198 | 678.012 ±7.668 |&#10;| **HashSet** | 5.979 ±2.629 | 8.064 ±1.829 | 48.097 ±6.905 | 234.718 ±33.061 |&#10;| **Dictionary** | 8.476 ±2.741 | 11.576 ±1.059 | 52.047 ±8.078 | 270.030 ±31.387 |&#10;| **SortedSet** | 18.718 ±3.282 | 35.197 ±4.057 | 195.994 ±24.099 | 538.773 ±21.496 |&#10;| **SortedDictionary** | 41.364 ±6.051 | 65.809 ±7.608 | 261.678 ±11.865 | 703.018 ±17.137 |&#10;| **ConcurrentDictionary** | 26.658 ±6.942 | 25.570 ±5.305 | 96.058 ±201.913 | 215.339 ±26.147 |&#10;| **ImmutableList** | 13.861 ±4.192 | 48.039 ±3.521 | 608.613 ±16.102 | 6381.622 ±305.664 |&#10;| **ImmutableHashSet** | 38.930 ±3.851 | 53.197 ±4.097 | 145.466 ±9.711 | 404.536 ±11.550 |&#10;&#10;### Large Collections (N=1,000)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 9.745 ±4.402 | 10.567 ±4.891 | 17.776 ±46.709 | 11.467 ±4.305 |&#10;| **List** | 9.788 ±5.021 | 9.006 ±4.181 | 16.958 ±43.496 | 11.313 ±5.968 |&#10;| **HashSet** | 65.273 ±63.349 | 65.400 ±58.472 | 63.397 ±51.984 | 54.650 ±8.442 |&#10;| **Dictionary** | 103.630 ±93.195 | 100.270 ±80.378 | 88.412 ±15.207 | 90.512 ±70.994 |&#10;| **SortedSet** | 226.413 ±18.413 | 225.122 ±21.400 | 228.303 ±18.784 | 249.000 ±210.170 |&#10;| **SortedDictionary** | 497.406 ±28.427 | 494.944 ±24.903 | 493.144 ±19.086 | 485.573 ±226.642 |&#10;| **ConcurrentDictionary** | 227.531 ±204.828 | 211.000 ±203.146 | 237.163 ±222.822 | 224.994 ±180.366 |&#10;| **ImmutableList** | 43.797 ±10.168 | 47.403 ±9.206 | 88.452 ±200.881 | 38.783 ±20.324 |&#10;| **ImmutableHashSet** | 426.528 ±23.438 | 404.291 ±30.415 | 428.241 ±17.662 | 429.528 ±29.438 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 2.697 ±0.274 | 33.009 ±0.886 | 359.761 ±22.760 | 5201.291 ±231.903 |&#10;| **List** | 2.715 ±0.246 | 33.330 ±1.721 | 364.942 ±22.071 | 4837.858 ±209.534 |&#10;| **HashSet** | 10.015 ±52.883 | 12.273 ±47.272 | 50.288 ±44.618 | 252.125 ±29.058 |&#10;| **Dictionary** | 1.127 ±0.492 | 4.794 ±0.592 | 51.612 ±6.999 | 250.055 ±33.025 |&#10;| **SortedSet** | 2.513 ±0.134 | 24.609 ±2.377 | 220.219 ±19.362 | 873.591 ±50.577 |&#10;| **SortedDictionary** | 3.169 ±0.186 | 31.622 ±3.280 | 283.719 ±14.239 | 1029.936 ±28.397 |&#10;| **ConcurrentDictionary** | 0.816 ±0.081 | 3.044 ±0.251 | 35.794 ±3.478 | 185.331 ±18.282 |&#10;| **ImmutableList** | 25.500 ±0.853 | 403.303 ±10.641 | 4072.597 ±812.170 | 26736.600 ±4084.863 |&#10;| **ImmutableHashSet** | 2.572 ±0.161 | 19.794 ±1.690 | 204.438 ±16.261 | 625.972 ±39.525 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 12.770 ±4.747 | 43.855 ±5.603 | 377.900 ±65.950 | 5213.312 ±233.083 |&#10;| **List** | 12.958 ±5.573 | 42.570 ±5.114 | 382.100 ±64.808 | 4850.306 ±212.857 |&#10;| **HashSet** | 75.418 ±116.037 | 77.797 ±105.538 | 113.806 ±96.413 | 306.900 ±29.873 |&#10;| **Dictionary** | 107.812 ±94.111 | 107.479 ±81.396 | 142.562 ±21.348 | 342.394 ±78.658 |&#10;| **SortedSet** | 229.044 ±18.474 | 249.859 ±22.090 | 448.606 ±27.948 | 1122.700 ±209.059 |&#10;| **SortedDictionary** | 500.691 ±28.524 | 526.713 ±25.893 | 776.981 ±28.925 | 1515.618 ±232.510 |&#10;| **ConcurrentDictionary** | 228.463 ±204.863 | 214.147 ±203.331 | 273.066 ±222.395 | 410.397 ±181.870 |&#10;| **ImmutableList** | 69.400 ±10.279 | 450.803 ±14.787 | 4161.242 ±830.837 | 26775.724 ±4082.112 |&#10;| **ImmutableHashSet** | 429.209 ±23.507 | 424.184 ±30.186 | 632.791 ±26.381 | 1055.650 ±66.742 |&#10;&#10;### Very Large Collections (N=10,000)&#10;&#10;#### Creation Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 11.188 ±6.735 | 10.167 ±4.669 | 27.336 ±52.884 | 30.806 ±47.362 |&#10;| **List** | 9.012 ±3.261 | 9.812 ±5.090 | 24.663 ±44.333 | 30.447 ±45.339 |&#10;| **HashSet** | 160.155 ±13.120 | 173.497 ±8.346 | 167.391 ±13.092 | 163.645 ±13.485 |&#10;| **Dictionary** | 328.839 ±33.102 | 346.291 ±46.257 | 317.612 ±57.678 | 305.621 ±40.856 |&#10;| **SortedSet** | 1714.833 ±87.405 | 1748.673 ±79.526 | 1606.967 ±159.071 | 1631.691 ±211.321 |&#10;| **SortedDictionary** | 3652.870 ±1299.900 | 3757.633 ±1325.771 | 3767.158 ±1403.329 | 4230.864 ±721.919 |&#10;| **ConcurrentDictionary** | 1014.221 ±159.810 | 1032.242 ±244.584 | 1010.727 ±237.796 | 1034.473 ±249.256 |&#10;| **ImmutableList** | 253.067 ±27.206 | 275.473 ±121.176 | 167.521 ±162.094 | 191.294 ±217.176 |&#10;| **ImmutableHashSet** | 4381.403 ±219.880 | 3950.852 ±822.654 | 4364.779 ±219.156 | 4343.752 ±200.290 |&#10;&#10;#### Lookup Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 23.170 ±0.595 | 345.594 ±15.450 | 3718.727 ±115.120 | 38423.988 ±1414.425 |&#10;| **List** | 22.155 ±1.523 | 304.503 ±13.836 | 3616.784 ±178.327 | 39002.788 ±1472.814 |&#10;| **HashSet** | 0.797 ±0.129 | 5.282 ±4.888 | 66.633 ±139.879 | 319.018 ±42.283 |&#10;| **Dictionary** | 0.879 ±0.134 | 4.858 ±0.221 | 75.370 ±140.002 | 354.306 ±29.709 |&#10;| **SortedSet** | 3.306 ±0.270 | 33.785 ±2.964 | 290.061 ±174.129 | 1188.842 ±104.962 |&#10;| **SortedDictionary** | 4.342 ±1.524 | 31.976 ±11.506 | 334.315 ±219.781 | 1458.942 ±108.588 |&#10;| **ConcurrentDictionary** | 0.867 ±0.176 | 3.948 ±0.750 | 70.603 ±156.816 | 283.188 ±24.125 |&#10;| **ImmutableList** | 259.473 ±13.636 | 3544.363 ±491.538 | 18766.090 ±3566.817 | 177408.515 ±4821.124 |&#10;| **ImmutableHashSet** | 3.267 ±0.471 | 23.139 ±7.678 | 277.658 ±238.989 | 949.321 ±50.099 |&#10;&#10;#### Total Time Performance (μs)&#10;| Collection Type | 10 Lookups | 100 Lookups | 1,000 Lookups | 10,000 Lookups |&#10;|----------------|------------|--------------|---------------|----------------|&#10;| **Array** | 34.467 ±7.125 | 355.833 ±16.623 | 3746.270 ±131.741 | 38455.165 ±1423.152 |&#10;| **List** | 31.242 ±3.666 | 314.415 ±17.443 | 3641.625 ±174.221 | 39033.729 ±1482.034 |&#10;| **HashSet** | 161.042 ±13.205 | 178.873 ±9.801 | 234.170 ±138.676 | 482.755 ±51.359 |&#10;| **Dictionary** | 329.939 ±33.472 | 351.515 ±46.425 | 393.509 ±154.203 | 660.494 ±69.189 |&#10;| **SortedSet** | 1718.303 ±87.469 | 1782.633 ±78.174 | 1897.200 ±241.467 | 2820.721 ±255.789 |&#10;| **SortedDictionary** | 3657.506 ±1300.594 | 3789.836 ±1336.556 | 4101.676 ±1520.568 | 5690.148 ±805.170 |&#10;| **ConcurrentDictionary** | 1015.248 ±159.957 | 1036.330 ±244.712 | 1081.455 ±283.056 | 1317.824 ±266.472 |&#10;| **ImmutableList** | 512.627 ±32.886 | 3819.950 ±415.556 | 18933.883 ±3573.977 | 177600.191 ±4913.886 |&#10;| **ImmutableHashSet** | 4384.936 ±219.933 | 3974.209 ±829.218 | 4642.682 ±338.314 | 5293.276 ±235.757 |&#10;&#10;## Performance Champions by Scenario&#10;&#10;###  Small Collections (N=10) Winners&#10;- **10 Lookups**: List (1.8 μs) &gt; Array (1.7 μs) &gt; HashSet (3.1 μs)&#10;- **100 Lookups**: List (2.9 μs) &gt; Array (2.7 μs) &gt; HashSet (5.1 μs)&#10;- **1,000 Lookups**: List (19.5 μs) &gt; Array (30.5 μs) &gt; HashSet (38.6 μs)&#10;- **10,000 Lookups**: List (103.4 μs) &gt; Array (101.1 μs) &gt; ConcurrentDictionary (145.7 μs)&#10;&#10;###  Medium Collections (N=100) Winners&#10;- **10 Lookups**: Array (2.0 μs) &gt; List (2.1 μs) &gt; HashSet (6.0 μs)&#10;- **100 Lookups**: Array (7.3 μs) &gt; List (7.9 μs) &gt; HashSet (8.1 μs)&#10;- **1,000 Lookups**: HashSet (48.1 μs) &gt; Dictionary (52.0 μs) &gt; List (69.4 μs)&#10;- **10,000 Lookups**: ConcurrentDictionary (215.3 μs) &gt; HashSet (234.7 μs) &gt; Dictionary (270.0 μs)&#10;&#10;###  Large Collections (N=1,000) Winners&#10;- **10 Lookups**: Array (12.8 μs) &gt; List (13.0 μs) &gt; HashSet (75.4 μs)&#10;- **100 Lookups**: List (42.6 μs) &gt; Array (43.9 μs) &gt; HashSet (77.8 μs)&#10;- **1,000 Lookups**: HashSet (113.8 μs) &gt; Dictionary (142.6 μs) &gt; ConcurrentDictionary (273.1 μs)&#10;- **10,000 Lookups**: HashSet (306.9 μs) &gt; Dictionary (342.4 μs) &gt; ConcurrentDictionary (410.4 μs)&#10;&#10;###  Very Large Collections (N=10,000) Winners&#10;- **10 Lookups**: List (31.2 μs) &gt; Array (34.5 μs) &gt; HashSet (161.0 μs)&#10;- **100 Lookups**: List (314.4 μs) &gt; Dictionary (351.5 μs) &gt; Array (355.8 μs)&#10;- **1,000 Lookups**: HashSet (234.2 μs) &gt; Dictionary (393.5 μs) &gt; ConcurrentDictionary (1,081.5 μs)&#10;- **10,000 Lookups**: **HashSet (482.8 μs)** &gt; **Dictionary (660.5 μs)** &gt; **ConcurrentDictionary (1,317.8 μs)**&#10;&#10;## Performance Disasters&#10;&#10;### ⚠️ Critical Performance Issues&#10;- **ImmutableList N=10,000, 10,000 lookups**: 177,600 μs (177.6 seconds!)&#10;- **Array N=10,000, 10,000 lookups**: 38,455 μs (38.5 seconds)&#10;- **List N=10,000, 10,000 lookups**: 39,034 μs (39.0 seconds)&#10;&#10;###  Performance Ratios (vs HashSet at N=10,000, 10,000 lookups)&#10;- **ImmutableList**: 368x slower&#10;- **Array**: 80x slower  &#10;- **List**: 81x slower&#10;- **SortedDictionary**: 12x slower&#10;- **ImmutableHashSet**: 11x slower&#10;&#10;## GUID-Specific Characteristics&#10;&#10;###  Why GUIDs Perform Differently&#10;1. **Memory Overhead**: 16 bytes vs 4 bytes (integers) = 4x memory usage&#10;2. **Hash Complexity**: 128-bit values require more complex hashing&#10;3. **Cache Efficiency**: Larger memory footprint reduces CPU cache effectiveness&#10;4. **Comparison Cost**: More expensive equality comparisons than primitive types&#10;&#10;###  GUID vs Integer Performance Impact&#10;Based on comparing with integer benchmarks:&#10;- **HashSet**: ~55% slower for GUIDs&#10;- **Dictionary**: ~122% slower for GUIDs  &#10;- **Array/List**: ~300% slower for GUIDs&#10;- **Memory Usage**: ~4x higher for GUID collections&#10;&#10;## Statistical Reliability&#10;&#10;### ✅ Most Reliable Collections (Low CV%)&#10;- **HashSet**: Consistent across all scenarios&#10;- **Dictionary**: Reliable for medium-large collections&#10;- **SortedSet**: Good reliability for ordered data&#10;&#10;### ❌ Unreliable Collections (High CV%)&#10;- **Array/List**: High variability in small collections&#10;- **ConcurrentDictionary**: Very high variability due to threading overhead&#10;- **ImmutableList**: Unpredictable performance scaling&#10;&#10;## Recommendations&#10;&#10;### ✅ **Primary Choices for GUID Collections**&#10;&#10;**For Membership Testing:**&#10;- **HashSet** - Excellent O(1) performance, scales perfectly&#10;&#10;**For Key-Value Storage:**&#10;- **Dictionary** - Consistent performance, reasonable memory usage&#10;&#10;**For Thread-Safe Operations:**&#10;- **ConcurrentDictionary** - Actually performs best in largest scenarios&#10;&#10;### ❌ **Avoid for GUID Collections**&#10;&#10;**Never Use:**&#10;- **ImmutableList** - Catastrophically slow (177+ seconds)&#10;- **Array/List** - Only for sequential access, never for lookups&#10;&#10;**Use Only If Necessary:**&#10;- **SortedDictionary** - Only if you absolutely need sorted iteration&#10;- **ImmutableHashSet** - Only if immutability is required&#10;&#10;###  **Decision Matrix**&#10;&#10;| Scenario | Best Choice | Alternative | Avoid |&#10;|----------|-------------|-------------|-------|&#10;| Small collections (N&lt;100) | Array/List | HashSet | ImmutableList |&#10;| Medium collections (100-1000) | HashSet | Dictionary | Array/List |&#10;| Large collections (N&gt;1000) | HashSet | Dictionary | Everything else |&#10;| Thread-safe operations | ConcurrentDictionary | HashSet + locks | All others |&#10;| Key-value pairs needed | Dictionary | ConcurrentDictionary | SortedDictionary |&#10;&#10;## Conclusion&#10;&#10;For GUID collections, the choice of data structure has an enormous impact on performance. Hash-based collections (HashSet, Dictionary) are not just better - they are absolutely essential for any scenario involving frequent lookups with more than 1,000 elements. The performance difference can be the difference between sub-millisecond operations and multi-second delays." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>