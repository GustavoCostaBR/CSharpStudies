<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ArrayOperationBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ArrayOperationBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class ArrayOperationBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntArray_IndexOf_Lookup()&#10;        {&#10;            var collection = intSourceData.ToArray();&#10;            foreach (var item in intLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringArray_IndexOf_Lookup()&#10;        {&#10;            var collection = stringSourceData.ToArray();&#10;            foreach (var item in stringLookupItems)&#10;                _ = Array.IndexOf(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntArray_BinarySearch_Lookup()&#10;        {&#10;            var collection = intSourceData.ToArray();&#10;            Array.Sort(collection);&#10;            foreach (var item in intLookupItems)&#10;                _ = Array.BinarySearch(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringArray_BinarySearch_Lookup()&#10;        {&#10;            var collection = stringSourceData.ToArray();&#10;            Array.Sort(collection);&#10;            foreach (var item in stringLookupItems)&#10;                _ = Array.BinarySearch(collection, item) &gt;= 0;&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntArray_Contains_Lookup()&#10;        {&#10;            var collection = intSourceData.ToArray();&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringArray_Contains_Lookup()&#10;        {&#10;            var collection = stringSourceData.ToArray();&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ConcurrentCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ConcurrentCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class ConcurrentCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntConcurrentDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentDictionary&lt;int, bool&gt;(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringConcurrentDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentDictionary&lt;string, bool&gt;(stringSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntConcurrentBag_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentBag&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringConcurrentBag_CreationAndLookup()&#10;        {&#10;            var collection = new ConcurrentBag&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/CustomReferenceTypeBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/CustomReferenceTypeBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    // Custom reference type for testing&#10;    public class Customer : IEquatable&lt;Customer&gt;, IComparable&lt;Customer&gt;&#10;    {&#10;        public string Id { get; }&#10;        public string Name { get; }&#10;        &#10;        public Customer(string id, string name)&#10;        {&#10;            Id = id;&#10;            Name = name;&#10;        }&#10;        &#10;        public bool Equals(Customer? other) =&gt; other != null &amp;&amp; Id == other.Id;&#10;        public override bool Equals(object? obj) =&gt; Equals(obj as Customer);&#10;        public override int GetHashCode() =&gt; Id?.GetHashCode() ?? 0;&#10;        &#10;        public int CompareTo(Customer? other)&#10;        {&#10;            if (other == null) return 1;&#10;            return string.Compare(Id, other.Id, StringComparison.Ordinal);&#10;        }&#10;    }&#10;&#10;    [MemoryDiagnoser]&#10;    public class CustomReferenceTypeBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private Customer[] customerSourceData = null!;&#10;        private Customer[] customerLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            customerSourceData = Enumerable.Range(1, N).Select(i =&gt; new Customer($&quot;CUST_{random.Next()}&quot;, $&quot;Customer {i}&quot;)).ToArray();&#10;            customerLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; new Customer($&quot;CUST_{random.Next()}&quot;, $&quot;Customer {i}&quot;)).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;Customer&gt;(customerSourceData);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;Customer&gt;(customerSourceData);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;Customer&gt;(customerSourceData);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void CustomerDictionary_CreationAndLookup()&#10;        {&#10;            var collection = customerSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in customerLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/CustomValueTypeBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/CustomValueTypeBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    // Custom value type for testing&#10;    public struct ProductId : IEquatable&lt;ProductId&gt;, IComparable&lt;ProductId&gt;&#10;    {&#10;        public int Value { get; }&#10;        &#10;        public ProductId(int value) =&gt; Value = value;&#10;        &#10;        public bool Equals(ProductId other) =&gt; Value == other.Value;&#10;        public override bool Equals(object? obj) =&gt; obj is ProductId other &amp;&amp; Equals(other);&#10;        public override int GetHashCode() =&gt; Value.GetHashCode();&#10;        public static implicit operator ProductId(int value) =&gt; new(value);&#10;        &#10;        public int CompareTo(ProductId other) =&gt; Value.CompareTo(other.Value);&#10;    }&#10;&#10;    [MemoryDiagnoser]&#10;    public class CustomValueTypeBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private ProductId[] productIdSourceData = null!;&#10;        private ProductId[] productIdLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            productIdSourceData = Enumerable.Range(1, N).Select(i =&gt; new ProductId(random.Next())).Distinct().Take(N).ToArray();&#10;            productIdLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; new ProductId(random.Next())).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;ProductId&gt;(productIdSourceData);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;ProductId&gt;(productIdSourceData);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;ProductId&gt;(productIdSourceData);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void ProductIdDictionary_CreationAndLookup()&#10;        {&#10;            var collection = productIdSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in productIdLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/GuidCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/GuidCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class GuidCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private Guid[] guidSourceData = null!;&#10;        private Guid[] guidLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            guidSourceData = Enumerable.Range(1, N).Select(i =&gt; Guid.NewGuid()).ToArray();&#10;            guidLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; Guid.NewGuid()).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;Guid&gt;(guidSourceData);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;Guid&gt;(guidSourceData);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;Guid&gt;(guidSourceData);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidDictionary_CreationAndLookup()&#10;        {&#10;            var collection = guidSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void GuidSortedDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new SortedDictionary&lt;Guid, bool&gt;(guidSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in guidLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ImmutableCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ImmutableCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Collections.Immutable;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class ImmutableCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableList_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableList.CreateRange(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableHashSet_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableHashSet.CreateRange(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableSortedSet.CreateRange(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringImmutableList_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableList.CreateRange(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringImmutableHashSet_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableHashSet.CreateRange(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntImmutableDictionary_CreationAndLookup()&#10;        {&#10;            var collection = ImmutableDictionary.CreateRange(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/IntegerCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/IntegerCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class IntegerCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private int[] intSourceData = null!;&#10;        private int[] intLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            intSourceData = Enumerable.Range(1, N).Select(i =&gt; random.Next()).Distinct().Take(N).ToArray();&#10;            intLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; random.Next()).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;int&gt;(intSourceData);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntDictionary_CreationAndLookup()&#10;        {&#10;            var collection = intSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void IntSortedDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new SortedDictionary&lt;int, bool&gt;(intSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in intLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/ParallelBenchmarkRunner.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/ParallelBenchmarkRunner.cs" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Concurrent;&#10;using System.Collections.Generic;&#10;using System.Diagnostics;&#10;using System.Threading.Tasks;&#10;using BenchmarkDotNet.Running;&#10;using BenchmarkDotNet.Configs;&#10;using BenchmarkDotNet.Jobs;&#10;using BenchmarkDotNet.Toolchains.CsProj;&#10;using BenchmarkDotNet.Toolchains.DotNetCli;&#10;&#10;namespace Benchmarks&#10;{&#10;    public class ParallelBenchmarkRunner&#10;    {&#10;        private readonly int _parallelInstances;&#10;        private readonly ManualConfig _releaseConfig;&#10;&#10;        public ParallelBenchmarkRunner(int parallelInstances = 8)&#10;        {&#10;            _parallelInstances = parallelInstances;&#10;            &#10;            // Create optimized release configuration&#10;            _releaseConfig = ManualConfig.Create(DefaultConfig.Instance)&#10;                .WithOptions(ConfigOptions.DisableOptimizationsValidator)&#10;                .AddJob(Job.Default&#10;                    .WithToolchain(CsProjCoreToolchain.NetCoreApp90)&#10;                    .WithId(&quot;ReleaseJob&quot;))&#10;                .WithOption(ConfigOptions.JoinSummary, true);&#10;        }&#10;&#10;        public async Task RunBenchmarksInParallel()&#10;        {&#10;            Console.WriteLine($&quot;Starting parallel benchmark execution with {_parallelInstances} instances...&quot;);&#10;            Console.WriteLine($&quot;CPU Core Count: {Environment.ProcessorCount}&quot;);&#10;            Console.WriteLine(new string('=', 80));&#10;&#10;            var benchmarkTasks = new List&lt;Task&gt;();&#10;            var results = new ConcurrentBag&lt;BenchmarkResult&gt;();&#10;            var stopwatch = Stopwatch.StartNew();&#10;&#10;            // Define different benchmark scenarios to run in parallel&#10;            var benchmarkScenarios = new List&lt;BenchmarkScenario&gt;&#10;            {&#10;                new(&quot;IntegerCollections&quot;, () =&gt; RunBenchmarkSafely&lt;IntegerCollectionBenchmarks&gt;()),&#10;                new(&quot;StringCollections&quot;, () =&gt; RunBenchmarkSafely&lt;StringCollectionBenchmarks&gt;()),&#10;                new(&quot;GuidCollections&quot;, () =&gt; RunBenchmarkSafely&lt;GuidCollectionBenchmarks&gt;()),&#10;                new(&quot;CustomValueTypes&quot;, () =&gt; RunBenchmarkSafely&lt;CustomValueTypeBenchmarks&gt;()),&#10;                new(&quot;CustomReferenceTypes&quot;, () =&gt; RunBenchmarkSafely&lt;CustomReferenceTypeBenchmarks&gt;()),&#10;                new(&quot;ImmutableCollections&quot;, () =&gt; RunBenchmarkSafely&lt;ImmutableCollectionBenchmarks&gt;()),&#10;                new(&quot;ConcurrentCollections&quot;, () =&gt; RunBenchmarkSafely&lt;ConcurrentCollectionBenchmarks&gt;()),&#10;                new(&quot;ArrayOperations&quot;, () =&gt; RunBenchmarkSafely&lt;ArrayOperationBenchmarks&gt;())&#10;            };&#10;&#10;            // Take only the number of scenarios we want to run in parallel&#10;            var scenariosToRun = benchmarkScenarios.Take(_parallelInstances);&#10;&#10;            foreach (var scenario in scenariosToRun)&#10;            {&#10;                var task = Task.Run(async () =&gt;&#10;                {&#10;                    var taskStopwatch = Stopwatch.StartNew();&#10;                    Console.WriteLine($&quot;[{DateTime.Now:HH:mm:ss}] Starting {scenario.Name}...&quot;);&#10;                    &#10;                    try&#10;                    {&#10;                        var result = await scenario.ExecuteAsync();&#10;                        taskStopwatch.Stop();&#10;                        &#10;                        var benchmarkResult = new BenchmarkResult&#10;                        {&#10;                            ScenarioName = scenario.Name,&#10;                            Success = result != null,&#10;                            Duration = taskStopwatch.Elapsed,&#10;                            ErrorMessage = result == null ? &quot;Benchmark returned null&quot; : null&#10;                        };&#10;                        &#10;                        results.Add(benchmarkResult);&#10;                        Console.WriteLine($&quot;[{DateTime.Now:HH:mm:ss}] Completed {scenario.Name} in {taskStopwatch.Elapsed:mm\\:ss}&quot;);&#10;                    }&#10;                    catch (Exception ex)&#10;                    {&#10;                        taskStopwatch.Stop();&#10;                        var benchmarkResult = new BenchmarkResult&#10;                        {&#10;                            ScenarioName = scenario.Name,&#10;                            Success = false,&#10;                            Duration = taskStopwatch.Elapsed,&#10;                            ErrorMessage = ex.Message&#10;                        };&#10;                        &#10;                        results.Add(benchmarkResult);&#10;                        Console.WriteLine($&quot;[{DateTime.Now:HH:mm:ss}] Failed {scenario.Name}: {ex.Message}&quot;);&#10;                    }&#10;                });&#10;                &#10;                benchmarkTasks.Add(task);&#10;            }&#10;&#10;            // Wait for all benchmarks to complete&#10;            await Task.WhenAll(benchmarkTasks);&#10;            stopwatch.Stop();&#10;&#10;            // Print summary&#10;            Console.WriteLine(&quot;\n&quot; + new string('=', 80));&#10;            Console.WriteLine(&quot;PARALLEL BENCHMARK EXECUTION SUMMARY&quot;);&#10;            Console.WriteLine(new string('=', 80));&#10;            Console.WriteLine($&quot;Total Execution Time: {stopwatch.Elapsed:mm\\:ss}&quot;);&#10;            Console.WriteLine($&quot;Parallel Instances: {_parallelInstances}&quot;);&#10;            Console.WriteLine();&#10;&#10;            foreach (var result in results)&#10;            {&#10;                var status = result.Success ? &quot;✓ SUCCESS&quot; : &quot;✗ FAILED&quot;;&#10;                Console.WriteLine($&quot;{status,-12} {result.ScenarioName,-25} Duration: {result.Duration:mm\\:ss}&quot;);&#10;                if (!result.Success &amp;&amp; !string.IsNullOrEmpty(result.ErrorMessage))&#10;                {&#10;                    Console.WriteLine($&quot;             Error: {result.ErrorMessage}&quot;);&#10;                }&#10;            }&#10;&#10;            var successCount = results.Count(r =&gt; r.Success);&#10;            var failCount = results.Count(r =&gt; !r.Success);&#10;            &#10;            Console.WriteLine();&#10;            Console.WriteLine($&quot;Results: {successCount} successful, {failCount} failed&quot;);&#10;            Console.WriteLine(new string('=', 80));&#10;        }&#10;&#10;        private async Task&lt;object&gt; RunBenchmarkSafely&lt;T&gt;() where T : class&#10;        {&#10;            return await Task.Run(() =&gt;&#10;            {&#10;                try&#10;                {&#10;                    return BenchmarkRunner.Run&lt;T&gt;(_releaseConfig);&#10;                }&#10;                catch (Exception ex)&#10;                {&#10;                    Console.WriteLine($&quot;Error running benchmark {typeof(T).Name}: {ex.Message}&quot;);&#10;                    throw;&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    public record BenchmarkScenario(string Name, Func&lt;Task&lt;object&gt;&gt; ExecuteAsync);&#10;&#10;    public class BenchmarkResult&#10;    {&#10;        public string ScenarioName { get; set; } = string.Empty;&#10;        public bool Success { get; set; }&#10;        public TimeSpan Duration { get; set; }&#10;        public string? ErrorMessage { get; set; }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/Program.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/Program.cs" />
              <option name="originalContent" value="&#10;namespace Benchmarks&#10;{&#10;    class Program&#10;    {&#10;        static async Task Main(string[] args)&#10;        {&#10;            Console.WriteLine(&quot;Parallel Benchmark Runner&quot;);&#10;            Console.WriteLine(&quot;=========================&quot;);&#10;            &#10;            // Parse command line arguments for parallel instances count&#10;            int parallelInstances = 8; // Default to 8 instances&#10;            &#10;            if (args.Length &gt; 0 &amp;&amp; int.TryParse(args[0], out int userInstances))&#10;            {&#10;                if (userInstances &gt;= 2 &amp;&amp; userInstances &lt;= 16)&#10;                {&#10;                    parallelInstances = userInstances;&#10;                }&#10;                else&#10;                {&#10;                    Console.WriteLine(&quot;Warning: Parallel instances should be between 2 and 16. Using default of 8.&quot;);&#10;                }&#10;            }&#10;            &#10;            Console.WriteLine($&quot;Running with {parallelInstances} parallel instances&quot;);&#10;            Console.WriteLine($&quot;Available CPU cores: {Environment.ProcessorCount}&quot;);&#10;            Console.WriteLine();&#10;            &#10;            var runner = new ParallelBenchmarkRunner(parallelInstances);&#10;            &#10;            try&#10;            {&#10;                await runner.RunBenchmarksInParallel();&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                Console.WriteLine($&quot;Error running parallel benchmarks: {ex.Message}&quot;);&#10;                Console.WriteLine($&quot;Stack trace: {ex.StackTrace}&quot;);&#10;                Environment.Exit(1);&#10;            }&#10;            &#10;            Console.WriteLine(&quot;\nPress any key to exit...&quot;);&#10;            Console.ReadKey();&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using System.Threading.Tasks;&#10;&#10;namespace Benchmarks&#10;{&#10;    class Program&#10;    {&#10;        static async Task Main(string[] args)&#10;        {&#10;            Console.WriteLine(&quot;Parallel Benchmark Runner&quot;);&#10;            Console.WriteLine(&quot;=========================&quot;);&#10;            &#10;            // Parse command line arguments for parallel instances count&#10;            int parallelInstances = 8; // Default to 8 instances&#10;            &#10;            if (args.Length &gt; 0 &amp;&amp; int.TryParse(args[0], out int userInstances))&#10;            {&#10;                if (userInstances &gt;= 2 &amp;&amp; userInstances &lt;= 16)&#10;                {&#10;                    parallelInstances = userInstances;&#10;                }&#10;                else&#10;                {&#10;                    Console.WriteLine(&quot;Warning: Parallel instances should be between 2 and 16. Using default of 8.&quot;);&#10;                }&#10;            }&#10;            &#10;            Console.WriteLine($&quot;Running with {parallelInstances} parallel instances&quot;);&#10;            Console.WriteLine($&quot;Available CPU cores: {Environment.ProcessorCount}&quot;);&#10;            Console.WriteLine();&#10;            &#10;            var runner = new ParallelBenchmarkRunner(parallelInstances);&#10;            &#10;            try&#10;            {&#10;                await runner.RunBenchmarksInParallel();&#10;            }&#10;            catch (Exception ex)&#10;            {&#10;                Console.WriteLine($&quot;Error running parallel benchmarks: {ex.Message}&quot;);&#10;                Console.WriteLine($&quot;Stack trace: {ex.StackTrace}&quot;);&#10;                Environment.Exit(1);&#10;            }&#10;            &#10;            Console.WriteLine(&quot;\nPress any key to exit...&quot;);&#10;            Console.ReadKey();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Topic6/Benchmarks/StringCollectionBenchmarks.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Topic6/Benchmarks/StringCollectionBenchmarks.cs" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using BenchmarkDotNet.Attributes;&#10;&#10;namespace Benchmarks&#10;{&#10;    [MemoryDiagnoser]&#10;    public class StringCollectionBenchmarks&#10;    {&#10;        [Params(1000, 10000)]&#10;        public int N;&#10;&#10;        [Params(1000, 10000)]&#10;        public int LookupCount;&#10;&#10;        private string[] stringSourceData = null!;&#10;        private string[] stringLookupItems = null!;&#10;&#10;        [GlobalSetup]&#10;        public void Setup()&#10;        {&#10;            var random = new Random(42);&#10;            stringSourceData = Enumerable.Range(1, N).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).Distinct().Take(N).ToArray();&#10;            stringLookupItems = Enumerable.Range(1, LookupCount).Select(i =&gt; $&quot;Item_{random.Next()}&quot;).ToArray();&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringList_CreationAndLookup()&#10;        {&#10;            var collection = new List&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringHashSet_CreationAndLookup()&#10;        {&#10;            var collection = new HashSet&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringSortedSet_CreationAndLookup()&#10;        {&#10;            var collection = new SortedSet&lt;string&gt;(stringSourceData);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.Contains(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringDictionary_CreationAndLookup()&#10;        {&#10;            var collection = stringSourceData.ToDictionary(x =&gt; x, x =&gt; true);&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;&#10;        [Benchmark]&#10;        public void StringSortedDictionary_CreationAndLookup()&#10;        {&#10;            var collection = new SortedDictionary&lt;string, bool&gt;(stringSourceData.ToDictionary(x =&gt; x, x =&gt; true));&#10;            foreach (var item in stringLookupItems)&#10;                _ = collection.ContainsKey(item);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>